<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  RISC-V Bytes: Rust Cross-Compilation · Daniel Mangum
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Daniel Mangum">
<meta name="description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
Today we are going to take a brief detour from our previous posts in this series and look at Rust Cross-Compilation for RISC-V. This will be a shorter post focused on providing useful information about how rustc works, as well as offering exact steps and configuration to target RISC-V when compiling your Rust programs.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://danielmangum.com/images/twitter-card.png"/>

<meta name="twitter:title" content="RISC-V Bytes: Rust Cross-Compilation"/>
<meta name="twitter:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
Today we are going to take a brief detour from our previous posts in this series and look at Rust Cross-Compilation for RISC-V. This will be a shorter post focused on providing useful information about how rustc works, as well as offering exact steps and configuration to target RISC-V when compiling your Rust programs."/>

<meta property="og:title" content="RISC-V Bytes: Rust Cross-Compilation" />
<meta property="og:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
Today we are going to take a brief detour from our previous posts in this series and look at Rust Cross-Compilation for RISC-V. This will be a shorter post focused on providing useful information about how rustc works, as well as offering exact steps and configuration to target RISC-V when compiling your Rust programs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://danielmangum.com/posts/risc-v-bytes-rust-cross-compilation/" /><meta property="og:image" content="https://danielmangum.com/images/twitter-card.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-30T00:10:34-06:00" />
<meta property="article:modified_time" content="2022-01-30T00:10:34-06:00" />




<link rel="canonical" href="https://danielmangum.com/posts/risc-v-bytes-rust-cross-compilation/">


<link rel="preload" href="https://danielmangum.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://danielmangum.com/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css" integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://danielmangum.com/css/coder-dark.min.216e36d3eaf6f4cdfd67dc1200c49a8169e6478102977b3e9ac51a064c57054c.css" integrity="sha256-IW420&#43;r29M39Z9wSAMSagWnmR4ECl3s&#43;msUaBkxXBUw=" crossorigin="anonymous" media="screen" />
  



 
  
    
    <link rel="stylesheet" href="https://danielmangum.com/css/custom.min.96ad7294e087b3b0719f71d369346642c5ad661660899f0b35025c5b10a70230.css" integrity="sha256-lq1ylOCHs7Bxn3HTaTRmQsWtZhZgiZ8LNQJcWxCnAjA=" crossorigin="anonymous" media="screen" />
  





<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://danielmangum.com/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://danielmangum.com/images/apple-touch-icon.png">

<link rel="manifest" href="https://danielmangum.com/site.webmanifest">
<link rel="mask-icon" href="https://danielmangum.com/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.111.3">





  </head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://danielmangum.com/">
      Daniel Mangum
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/categories/risc-v-bytes/">[RISC-V Bytes]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/risc-v-tips/">[RISC-V Tips]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/posts/">[Blog]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/about/">[About]</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://danielmangum.com/posts/risc-v-bytes-rust-cross-compilation/">
              RISC-V Bytes: Rust Cross-Compilation
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-01-30T00:10:34-06:00">
                January 30, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              14-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="https://danielmangum.com/categories/risc-v-bytes/">RISC-V Bytes</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
        <blockquote>
<p>This is part of a series on the blog where we explore
<a href="https://riscv.org/">RISC-V</a> by breaking down real programs and explaining how
they work. You can view all posts in this series on the <a href="https://danielmangum.com/categories/risc-v-bytes">RISC-V Bytes
page</a>.</p>
</blockquote>
<p>Today we are going to take a brief detour from our previous posts in this series
and look at <a href="https://rust-lang.github.io/rustup/cross-compilation.html">Rust
Cross-Compilation</a>
for RISC-V. This will be a shorter post focused on providing useful information
about <a href="https://doc.rust-lang.org/rustc/what-is-rustc.html">how <code>rustc</code> works</a>,
as well as offering exact steps and configuration to target RISC-V when
compiling your Rust programs. There are a number of existing references for
building Rust programs for RISC-V, but I have found that many of them are
targeting a bare metal (i.e. <code>no_std</code>) use case, such as running embedded code
on a microcontroller, or they don&rsquo;t provide much background context on why
various configuration is being used and how required tooling is being managed.
I&rsquo;ll attempt to be more comprehensive here, and will also do my best to post any
updates as the ecosystem continues to evolve. Let&rsquo;s get started!</p>
<h2 id="background">
  Background
  <a class="heading-link" href="#background">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<blockquote>
<p>If you are already a seasoned Rust programmer feel free to skip this section.</p>
</blockquote>
<p>While <code>rustc</code> is the Rust compiler, most Rust projects make use of two other
tools to invoke and manage <code>rustc</code>: <code>cargo</code> and <code>rustup</code>. <a href="https://rust-lang.github.io/rustup/"><code>rustup</code> is an
<em>installer</em></a>, meaning that it will handle
making sure you have the correct versions of <code>rustc</code> and <a href="https://rust-lang.github.io/rustup/concepts/components.html">other language
components</a> from
<a href="https://rust-lang.github.io/rustup/concepts/channels.html">the various
<em>channels</em></a> for
<em>toolchains</em> you are using, as well as ensuring that the standard library is
installed for every compilation <em>target</em>. <code>cargo</code> is the Rust <a href="https://doc.rust-lang.org/cargo/">package manager
and build tool</a>, and itself can be installed
using <code>rustup</code>. Throughout this post we will only be interacting with <code>rustc</code>
via <code>cargo</code> and its related configuration. Before we move forward, make sure
that you have <a href="https://www.rust-lang.org/tools/install">followed the
instructions</a> to install <code>rustup</code>.</p>
<blockquote>
<p><code>rustc</code> is distributed via <code>stable</code>, <code>beta</code>, and <code>nightly</code> channels. You may
opt to consume from a channel other than <code>stable</code> if there are features
required that have not been included in a formal release.</p>
</blockquote>
<h3 id="hosts-vs-targets">
  Hosts vs. Targets
  <a class="heading-link" href="#hosts-vs-targets">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>It&rsquo;s worth taking a moment to explicitly distinguish <em>toolchains</em> and
<em>supporting libraries</em>, which can be confusing for folks who are not already
familiar with cross-compilation. A toolchain is the set of tools required to
build artifacts on a specific <em>host machine</em>. For example, I am using a 64-bit
Linux machine (or <code>x86_64-unknown-linux-gnu</code> in Rust target parlance), and I
typically want to build artifacts that can run on a 64-bit Linux machine (i.e.
the same machine). I also sometimes want to build artifacts that can run on
other types of machines, which is what we are doing today. Cross-compilation
refers to any time that the <em>host machine</em> does not match the <em>target machine</em>.</p>
<blockquote>
<p><code>x86_64-unknown-linux-gnu</code> and other machine type identifiers are referred to
as <em>target triples</em>.</p>
</blockquote>
<p>With this in mind, you may have guessed that since we are only ever going to be
building on my 64-bit Linux machine, we only need the <code>x86_64-unknown-linux-gnu</code>
toolchain. However, because we are interested in cross-compiling to a RISC-V
machine, we are going to need to add an additional <em>target</em> for our 64-bit Linux
<em>toolchain</em>. This can be summarized by the following:</p>
<ul>
<li>A <em>toolchain</em> is needed for every type of <em>host machine</em>.</li>
<li><em>Supporting libraries</em> are needed for every type of <em>target machine</em>.</li>
</ul>
<blockquote>
<p><code>rustc</code> is inherently a cross-compiler, meaning that we can use the same host
toolchain to compile for many different targets as long as we have the
supporting libraries. This is not true of all other compiler toolchains. For
example, <code>gcc</code>, as we will see later, requires a separate compiler for every
host/target pair.</p>
</blockquote>
<p>Rust uses a familiar <a href="https://doc.rust-lang.org/nightly/rustc/platform-support.html">three-tier hierarchy for target
support</a>, which
could really be broken out into six tiers. Using the same vernacular as above,
the six tiers could be translated as:</p>
<ul>
<li><code>Tier 1 with Host Tools</code>: <em>toolchain</em> and <em>target</em> both available and
guaranteed to work.</li>
<li><code>Tier 1</code>: <em>target</em> available and guaranteed to work. There are no targets in
this tier today.</li>
<li><code>Tier 2 with Host Tools</code>: <em>toolchain</em> and <em>target</em> both available and
guaranteed to build.</li>
<li><code>Tier 2</code>: <em>target</em> available and guaranteed to build. Standard library may or
may not be supported.</li>
<li><code>Tier 3 with Host Tools</code>: <em>toolchain</em> and <em>target</em> are supported but not
built, distributed, or guaranteed to work.</li>
<li><code>Tier 3</code>: <em>target</em> is supported but not built, distributed, or guaranteed to
work. Standard library may or may not be supported.</li>
</ul>
<h2 id="setup">
  Setup
  <a class="heading-link" href="#setup">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Now that we know what components are required to build Rust programs on and for
various machines, we can install the toolchain for our <em>host machine</em> and
bootstrap a project. First lets check what toolchains are already present:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ rustup toolchain list
</span></span><span style="display:flex;"><span>stable-x86_64-unknown-linux-gnu (default)
</span></span></code></pre></div><p><code>rustup</code> has already installed the default toolchain for our machine, so we
don&rsquo;t need to take any other steps on that front. We can take a look at the
components of the toolchain in
<code>~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ls ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/bin
</span></span><span style="display:flex;"><span>cargo  cargo-clippy  cargo-fmt  clippy-driver  rustc  rustdoc  rustfmt  rust-gdb  rust-gdbgui  rust-lldb
</span></span></code></pre></div><p>You&rsquo;ll notice both <code>cargo</code> and <code>rustc</code> are present, as well as a number of other
tools, such as formatters and debuggers. When you install a toolchain, <code>rustup</code>
will also install required <em>target</em> libraries for that same type of machine:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ls ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/x86_64-unknown-linux-gnu/lib/
</span></span><span style="display:flex;"><span>libaddr2line-e8504b1ed73d6c6f.rlib          libhashbrown-6c448d94453f4d95.rlib     libprofiler_builtins-2b27848f56b860ee.rlib          librustc_std_workspace_std-e2232747f29a2298.rlib
</span></span><span style="display:flex;"><span>libadler-671a9f10c55c6c87.rlib              liblibc-b4424726f33da388.rlib          librustc_demangle-7c5cb27d99d10614.rlib             libstd-4c74cbab78ec4891.rlib
</span></span><span style="display:flex;"><span>liballoc-aa0bad4c4d134922.rlib              libmemchr-bed369233e55d851.rlib        librustc-stable_rt.asan.a                           libstd-4c74cbab78ec4891.so
</span></span><span style="display:flex;"><span>libcfg_if-c0badcb9f7c5eab7.rlib             libminiz_oxide-e35e56ad39c7e20e.rlib   librustc-stable_rt.lsan.a                           libstd_detect-0ddec007a0883060.rlib
</span></span><span style="display:flex;"><span>libcompiler_builtins-5667a4a7e2c48d47.rlib  libobject-ee577127549b7793.rlib        librustc-stable_rt.msan.a                           libtest-3d8d1f7e04ea304d.rlib
</span></span><span style="display:flex;"><span>libcore-6cfcec236d576603.rlib               libpanic_abort-b6371bac4bee0de9.rlib   librustc-stable_rt.tsan.a                           libtest-3d8d1f7e04ea304d.so
</span></span><span style="display:flex;"><span>libgetopts-86970f502db1b86e.rlib            libpanic_unwind-0ef58120f7b95253.rlib  librustc_std_workspace_alloc-22835d1ac5e3244b.rlib  libunicode_width-86b36790f7c9a304.rlib
</span></span><span style="display:flex;"><span>libgimli-411eeeec028606dc.rlib              libproc_macro-b961a3f930b2d0eb.rlib    librustc_std_workspace_core-483ad457673e0f5c.rlib   libunwind-84878e033904a7a4.rlib
</span></span></code></pre></div><p>So we have support for building on and for <code>x86_64-unknown-linux-gnu</code> machines,
but we need to add <em>target</em> support for RISC-V. No RISC-V targets are supported
in Tier 1, but <code>riscv64gc-unknown-linux-gnu</code> is supported in Tier 2 (it also
includes host tools, which we will not be using today). Let&rsquo;s go ahead and tell
<code>rustup</code> to add support:</p>
<blockquote>
<p>All Tier 3 RISC-V targets (<code>riscv32i-unknown-none-elf</code>,
<code>riscv32imac-unknown-none-elf</code>, <code>riscv32imc-unknown-none-elf</code>,
<code>riscv64gc-unknown-none-elf</code>, <code>riscv64imac-unknown-none-elf</code>) only support
<code>no_std</code> development. More on this in a bit.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ rustup target add riscv64gc-unknown-linux-gnu
</span></span><span style="display:flex;"><span>info: downloading component &#39;rust-std&#39; for &#39;riscv64gc-unknown-linux-gnu&#39;
</span></span><span style="display:flex;"><span>info: installing component &#39;rust-std&#39; for &#39;riscv64gc-unknown-linux-gnu&#39;
</span></span><span style="display:flex;"><span> 22.4 MiB /  22.4 MiB (100 %)  13.5 MiB/s in  1s ETA:  0s
</span></span></code></pre></div><p>You&rsquo;ll notice that all <code>rustup</code> does here is add library support (i.e. we are
not downloading a RISC-V toolchain). We can see now that these libraries live
under the <code>x86_64-unknown-linux-gnu</code> toolchain directory in a new
<code>riscv64gc-unknown-linux-gnu</code> directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ ls ~/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/riscv64gc-unknown-linux-gnu/lib/
</span></span><span style="display:flex;"><span>libaddr2line-b9f13a31d36ace4d.rlib          libgimli-26f1e8e2a29c6abc.rlib        libpanic_unwind-f075600c05f846f9.rlib               libstd-b9a58deffd9afad7.so
</span></span><span style="display:flex;"><span>libadler-e58e6ef377f5b261.rlib              libhashbrown-68b1f88e6bc5c009.rlib    libproc_macro-77a9b848fe88e73b.rlib                 libstd_detect-b0b3246e370d99f5.rlib
</span></span><span style="display:flex;"><span>liballoc-08e2a49fbdb36fe7.rlib              liblibc-1162f95a581d7874.rlib         librustc_demangle-4132820dd26e4dd2.rlib             libtest-33230b1de6d8a7e4.rlib
</span></span><span style="display:flex;"><span>libcfg_if-57cb37c2109ec8d3.rlib             libmemchr-4ea2a6be1c1298e6.rlib       librustc_std_workspace_alloc-69bfa5a0f9a81fa5.rlib  libtest-33230b1de6d8a7e4.so
</span></span><span style="display:flex;"><span>libcompiler_builtins-09da015b98bbb243.rlib  libminiz_oxide-3579444854cd0b3b.rlib  librustc_std_workspace_core-cb5020bd1de8755e.rlib   libunicode_width-c8ae7d271f61c6bd.rlib
</span></span><span style="display:flex;"><span>libcore-e22fac431ac00ff6.rlib               libobject-361332bd32322cb1.rlib       librustc_std_workspace_std-65dffd0afcdbdc70.rlib    libunwind-4d764747497457ba.rlib
</span></span><span style="display:flex;"><span>libgetopts-4abf1528f3149ce7.rlib            libpanic_abort-e8bba43be6b6e1d1.rlib  libstd-b9a58deffd9afad7.rlib
</span></span></code></pre></div><p>With these components in place, let&rsquo;s try to build something.</p>
<h2 id="building">
  Building
  <a class="heading-link" href="#building">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>We can setup a new project using <code>cargo</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cargo new rusty-risc
</span></span></code></pre></div><p>This will give us the following directory structure:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.
</span></span><span style="display:flex;"><span>└── rusty-risc
</span></span><span style="display:flex;"><span>    ├── Cargo.toml
</span></span><span style="display:flex;"><span>    └── src
</span></span><span style="display:flex;"><span>        └── main.rs
</span></span></code></pre></div><p>By default, <code>cargo</code> is going to give us a fairly straightforward &ldquo;Hello, world!&rdquo;
program in <code>main.rs</code>. However, while it may look simple, this program is
actually doing quite a lot.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> main() {
</span></span><span style="display:flex;"><span>    println!(<span style="color:#0ff;font-weight:bold">&#34;Hello, world!&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In order for the <code>println!</code>
<a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro</a> to show text in our
terminal, it is going to need to be able to perform I/O, which requires
interacting with the operating system via syscalls, typically accessed by
<code>libc</code>. The Rust standard library handles that interaction for us, and we saw
earlier that <code>rustup</code> took care of downloading it for our
<code>riscv64gc-unknown-linux-gnu</code>. Let&rsquo;s see how far that gets us.</p>
<p>As mentioned before, we are going to use <code>cargo</code> to build our program. <code>cargo</code>
supports passing configuration via flags or a configuration file. In order to
keep track of all of our configuration, we&rsquo;ll use the latter by creating a
<code>.cargo</code> directory in the project and adding a <code>config.toml</code> inside. Initially,
we only need to specify that we want to build for <code>riscv64gc-unknown-linux-gnu</code>:</p>
<p><code>./.cargo/config.toml</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[build]
</span></span><span style="display:flex;"><span>target = <span style="color:#0ff;font-weight:bold">&#34;riscv64gc-unknown-linux-gnu&#34;</span>
</span></span></code></pre></div><p>Now any time we invoke <code>cargo build</code>, we should only build for the specified
target. However, if we give it a try, we&rsquo;ll see that we immediately hit some
issues (output condensed):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">$</span> (rusty-risc) cargo build
</span></span><span style="display:flex;"><span>   Compiling rusty-risc v0.<span style="color:#ff0;font-weight:bold">1</span>.<span style="color:#ff0;font-weight:bold">0</span> (/home/dan/code/github.com/hasheddan/testing/rusty-risc)
</span></span><span style="display:flex;"><span>error: linking <span style="color:#fff;font-weight:bold">with</span> `cc` failed: <span style="color:#fff;font-weight:bold">exit</span> status: <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>          /usr/bin/ld: /home/dan/code/github.com/hasheddan/testing/rusty-risc/target/riscv64gc-unknown-linux-gnu/debug/deps/rusty_risc-c85960b13f0f920c.<span style="color:#ff0;font-weight:bold">26</span>a7wz4sk6dm01p0.rcgu.o: Relocations <span style="color:#fff;font-weight:bold">in</span> generic ELF (EM: <span style="color:#ff0;font-weight:bold">243</span>)
</span></span><span style="display:flex;"><span>          /usr/bin/ld: /home/dan/code/github.com/hasheddan/testing/rusty-risc/target/riscv64gc-unknown-linux-gnu/debug/deps/rusty_risc-c85960b13f0f920c.<span style="color:#ff0;font-weight:bold">26</span>a7wz4sk6dm01p0.rcgu.o: error adding symbols: file <span style="color:#fff;font-weight:bold">in</span> wrong format
</span></span><span style="display:flex;"><span>          collect2: error: ld returned <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#fff;font-weight:bold">exit</span> status
</span></span></code></pre></div><p>There are a few things to notice here. First of all the overall error says that
we are linking with <code>cc</code>. This is typically a symbolic link to the system&rsquo;s C
compiler, which on my Ubuntu machine is going to be <code>gcc</code>. We can double check
with the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) which cc
</span></span><span style="display:flex;"><span>/usr/bin/cc
</span></span><span style="display:flex;"><span>$ (rusty-risc) readlink -f /usr/bin/cc
</span></span><span style="display:flex;"><span>/usr/bin/x86_64-linux-gnu-gcc-9
</span></span></code></pre></div><p>Since this is an <code>x86_64-linux</code> compiler and we are targeting <code>riscv-64</code>, it
makes sense that this would cause problems, but why is Rust choosing to use <code>cc</code>
and does it choose to for every target? The answer is no and defaults can be
found in the <code>rustc</code> source.</p>
<blockquote>
<p>File names are links to source.</p>
</blockquote>
<p><a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/riscv64gc_unknown_linux_gnu.rs"><code>rust/compiler/rustc_target/src/spec/riscv64gc_unknown_linux_gnu.rs</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::spec::{CodeModel, Target, TargetOptions};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> target() -&gt; Target {
</span></span><span style="display:flex;"><span>    Target {
</span></span><span style="display:flex;"><span>        llvm_target: <span style="color:#0ff;font-weight:bold">&#34;riscv64-unknown-linux-gnu&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        pointer_width: <span style="color:#ff0;font-weight:bold">64</span>,
</span></span><span style="display:flex;"><span>        data_layout: <span style="color:#0ff;font-weight:bold">&#34;e-m:e-p:64:64-i64:64-i128:128-n64-S128&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        arch: <span style="color:#0ff;font-weight:bold">&#34;riscv64&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        options: TargetOptions {
</span></span><span style="display:flex;"><span>            code_model: <span style="color:#fff;font-weight:bold">Some</span>(CodeModel::Medium),
</span></span><span style="display:flex;"><span>            cpu: <span style="color:#0ff;font-weight:bold">&#34;generic-rv64&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            features: <span style="color:#0ff;font-weight:bold">&#34;+m,+a,+f,+d,+c&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            llvm_abiname: <span style="color:#0ff;font-weight:bold">&#34;lp64d&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            max_atomic_width: <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">64</span>),
</span></span><span style="display:flex;"><span>            ..<span style="color:#fff;font-weight:bold">super</span>::linux_gnu_base::opts()
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we can see that the <code>TargetOptions</code> set a few values, then ultimately defer
to the base options for GNU/Linux, which are mostly the same a base Linux, which
consume the overall target defaults:</p>
<p><a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/linux_gnu_base.rs"><code>rust/compiler/rustc_target/src/spec/linux_gnu_base.rs</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::spec::TargetOptions;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> opts() -&gt; TargetOptions {
</span></span><span style="display:flex;"><span>    TargetOptions { env: <span style="color:#0ff;font-weight:bold">&#34;gnu&#34;</span>.to_string(), ..<span style="color:#fff;font-weight:bold">super</span>::linux_base::opts() }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/linux_base.rs"><code>rust/compiler/rustc_target/src/spec/linux_base.rs</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::spec::{RelroLevel, TargetOptions};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> opts() -&gt; TargetOptions {
</span></span><span style="display:flex;"><span>    TargetOptions {
</span></span><span style="display:flex;"><span>        os: <span style="color:#0ff;font-weight:bold">&#34;linux&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        dynamic_linking: true,
</span></span><span style="display:flex;"><span>        executables: true,
</span></span><span style="display:flex;"><span>        families: vec![<span style="color:#0ff;font-weight:bold">&#34;unix&#34;</span>.to_string()],
</span></span><span style="display:flex;"><span>        has_rpath: true,
</span></span><span style="display:flex;"><span>        position_independent_executables: true,
</span></span><span style="display:flex;"><span>        relro_level: RelroLevel::Full,
</span></span><span style="display:flex;"><span>        has_thread_local: true,
</span></span><span style="display:flex;"><span>        crt_static_respected: true,
</span></span><span style="display:flex;"><span>        ..<span style="color:#fff;font-weight:bold">Default</span>::default()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Ultimately, if we drill down into the defaults, we&rsquo;ll find that the default
<code>linker_flavor</code> is in fact <code>gcc</code>:</p>
<p><a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/mod.rs#L1437"><code>rust/compiler/rustc_target/src/spec/mod.rs#L1437</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            linker_flavor: LinkerFlavor::Gcc,
</span></span><span style="display:flex;"><span>            linker: option_env!(<span style="color:#0ff;font-weight:bold">&#34;CFG_DEFAULT_LINKER&#34;</span>).map(|s| s.to_string()),
</span></span></code></pre></div><p>So that explains why we are invoking <code>cc</code>, but while we are here, its worth
noticing that <code>linux_base.rs</code> also <a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/linux_base.rs#L6">sets <code>dynamic_linking: true</code></a>,
which is <a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/mod.rs#L1446">not the
default</a>.
This is not the case for the Tier 3 <code>riscv64gc-unknown-none-elf</code> target, which
consumes the default behavior to produce static binaries, but <a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/riscv64gc_unknown_none_elf.rs#L13">overrides the
default
linker</a>
to be <code>rust-lld</code>:</p>
<p><a href="https://github.com/rust-lang/rust/blob/42313dd29b3edb0ab453a0d43d12876ec7e48ce0/compiler/rustc_target/src/spec/riscv64gc_unknown_none_elf.rs"><code>rust/compiler/rustc_target/src/spec/riscv64gc_unknown_none_elf.rs</code></a></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::spec::{CodeModel, LinkerFlavor, LldFlavor, PanicStrategy, RelocModel};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> <span style="color:#fff;font-weight:bold">crate</span>::spec::{Target, TargetOptions};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">pub</span> <span style="color:#fff;font-weight:bold">fn</span> target() -&gt; Target {
</span></span><span style="display:flex;"><span>    Target {
</span></span><span style="display:flex;"><span>        data_layout: <span style="color:#0ff;font-weight:bold">&#34;e-m:e-p:64:64-i64:64-i128:128-n64-S128&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        llvm_target: <span style="color:#0ff;font-weight:bold">&#34;riscv64&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>        pointer_width: <span style="color:#ff0;font-weight:bold">64</span>,
</span></span><span style="display:flex;"><span>        arch: <span style="color:#0ff;font-weight:bold">&#34;riscv64&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        options: TargetOptions {
</span></span><span style="display:flex;"><span>            linker_flavor: LinkerFlavor::Lld(LldFlavor::Ld),
</span></span><span style="display:flex;"><span>            linker: <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#0ff;font-weight:bold">&#34;rust-lld&#34;</span>.to_string()),
</span></span><span style="display:flex;"><span>            llvm_abiname: <span style="color:#0ff;font-weight:bold">&#34;lp64d&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            cpu: <span style="color:#0ff;font-weight:bold">&#34;generic-rv64&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            max_atomic_width: <span style="color:#fff;font-weight:bold">Some</span>(<span style="color:#ff0;font-weight:bold">64</span>),
</span></span><span style="display:flex;"><span>            features: <span style="color:#0ff;font-weight:bold">&#34;+m,+a,+f,+d,+c&#34;</span>.to_string(),
</span></span><span style="display:flex;"><span>            executables: true,
</span></span><span style="display:flex;"><span>            panic_strategy: PanicStrategy::Abort,
</span></span><span style="display:flex;"><span>            relocation_model: RelocModel::Static,
</span></span><span style="display:flex;"><span>            code_model: <span style="color:#fff;font-weight:bold">Some</span>(CodeModel::Medium),
</span></span><span style="display:flex;"><span>            emit_debug_gdb_scripts: false,
</span></span><span style="display:flex;"><span>            eh_frame_header: false,
</span></span><span style="display:flex;"><span>            ..<span style="color:#fff;font-weight:bold">Default</span>::default()
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This makes sense as the <code>riscv64gc-unknown-none-elf</code> target is not expecting to
be able to target a Linux platform, and thus presumably will not need to link
<code>libc</code> or load shared libraries at runtime (i.e. dynamically linked). However,
as mentioned before, this also means that we cannot use the Rust standard
library. In fact, if we use <code>rustup</code> to add the <code>riscv64gc-unknown-none-elf</code>
target and change our build to use it, we&rsquo;ll see an error indicating that we
must declare <code>#![no_std]</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">$</span> rustup target <span style="color:#fff;font-weight:bold">add</span> riscv64gc-unknown-none-elf
</span></span><span style="display:flex;"><span>info: downloading component <span style="color:#0ff;font-weight:bold">&#39;rust-std&#39;</span> <span style="color:#fff;font-weight:bold">for</span> <span style="color:#0ff;font-weight:bold">&#39;riscv64gc-unknown-none-elf&#39;</span>
</span></span><span style="display:flex;"><span>info: installing component <span style="color:#0ff;font-weight:bold">&#39;rust-std&#39;</span> <span style="color:#fff;font-weight:bold">for</span> <span style="color:#0ff;font-weight:bold">&#39;riscv64gc-unknown-none-elf&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">$</span> rustup tarcargo build
</span></span><span style="display:flex;"><span>   Compiling rusty-risc v0.<span style="color:#ff0;font-weight:bold">1</span>.<span style="color:#ff0;font-weight:bold">0</span> (/home/dan/code/github.com/hasheddan/testing/rusty-risc)
</span></span><span style="display:flex;"><span>error[E0463]: can<span style="color:#0ff;font-weight:bold">&#39;t find crate for `std`
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">  |
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">  = note: the `riscv64gc-unknown-none-elf` target may not support the standard library
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">  = note: `std` is required by `rusty_risc` because it does not declare `#![no_std]`
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">For more information about this error, try `rustc --explain E0463`.
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">error: could not compile `rusty-risc` due to previous error
</span></span></span></code></pre></div><p>If we were to change our <code>main.rs</code> to contain a very small <code>#![no_std]</code> program,
perhaps the one in <a href="https://docs.rust-embedded.org/embedonomicon/smallest-no-std.html"><em>The
Embedonomicon</em></a>,
we would see that it builds successfully:</p>
<p><code>./src/main.rs</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#![no_main]</span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#![no_std]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">use</span> core::panic::PanicInfo;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#[panic_handler]</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">fn</span> panic(_panic: <span style="color:#fff;font-weight:bold">&amp;</span>PanicInfo&lt;<span style="color:#fff;font-weight:bold">&#39;_</span>&gt;) -&gt; ! {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">loop</span> {}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) cargo build
</span></span><span style="display:flex;"><span>   Compiling rusty-risc v0.1.0 (/home/dan/code/github.com/hasheddan/testing/rusty-risc)
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.11s
</span></span></code></pre></div><blockquote>
<p>Though this compiles, we would not be able to run it under a normal userspace
emulator (more on this below).</p>
</blockquote>
<p>This is important as we did not have to download any RISC-V toolchain (outside
of the <code>rustup</code> target) to be able to build for <code>riscv64gc-unknown-none-elf</code>.
You&rsquo;ll frequently see bare metal RISC-V Rust projects, such as
<a href="https://github.com/riscv-rust/riscv-rust-quickstart"><code>riscv-rust-quickstart</code></a>
and <a href="https://blog.stephenmarz.com/">Stephen Marz&rsquo;s</a> fantastic
<a href="https://github.com/sgmarz/osblog"><code>osblog</code></a> take advantage of this. In fact,
you can see where
<a href="https://github.com/riscv-rust/riscv-rust-quickstart/commit/d8ef853e8c240b34ca8fb315989b88732a399ebb#diff-f6009bd0d260464389ace37ab2f89adae993e1fa4a47f779e4c9859937005ced">each</a>
of
<a href="https://github.com/sgmarz/osblog/commit/aba5fe0e24dd22eb497964601c32ed0809c64c7c#diff-fbd9b5b2cb726c5621a2e1545fa79ce3f0a0444ead69e204f5592f7d1cc5066c">them</a>
switched from explicitly specifying an external linker to using Rust&rsquo;s default
for <code>riscv64gc-unknown-none-elf</code> and <code>riscv32imac-unknown-none-elf</code>
respectively. However, we want to build a program that can run on a Linux
system, so we don&rsquo;t have this luxury.</p>
<p>Fortunately, some awesome RISC-V folks have a <a href="https://github.com/riscv-collab/riscv-gnu-toolchain"><code>riscv-gnu-toolchain</code>
repository</a> with detailed
instructions on how you can build a cross-compiler. If you&rsquo;re running Ubuntu, as
I am, they also publish periodic builds that you can download and install. As of
the writing of this post, I am using the <a href="https://github.com/riscv-collab/riscv-gnu-toolchain/releases/tag/2022.01.17"><code>2022.01.17</code>
release</a>
for <code>riscv64-glibc-ubuntu-20.04</code>.</p>
<p>Now that we have our toolchain, let&rsquo;s swap back to our &ldquo;Hello, world!&rdquo; program
and change our target back to <code>riscv64gc-unknown-linux-gnu</code>. We can add a
target-specific linker to override the default <code>cc</code> that Rust will use:</p>
<p><code>./.cargo/config.toml</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[build]
</span></span><span style="display:flex;"><span>target = <span style="color:#0ff;font-weight:bold">&#34;riscv64gc-unknown-linux-gnu&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[target.riscv64gc-unknown-linux-gnu]
</span></span><span style="display:flex;"><span>linker = <span style="color:#0ff;font-weight:bold">&#34;riscv64-unknown-linux-gnu-gcc&#34;</span>
</span></span></code></pre></div><p>Alright, let&rsquo;s see how that goes:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) cargo build
</span></span><span style="display:flex;"><span>   Compiling rusty-risc v0.1.0 (/home/dan/code/github.com/hasheddan/testing/rusty-risc)
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
</span></span></code></pre></div><p>Looks good! Now in order to see if this runs succesfully, we are going to need
to acquire a userspace emulator for 64-bit RISC-V. If you haven&rsquo;t already
installed <a href="https://www.qemu.org/">QEMU</a> head back to the <a href="https://danielmangum.com/posts/risc-v-bytes-qemu-gdb/">first RISC-V Bytes
post</a> where we looked at
cross-platform debugging for download instructions. Once installed, we should be
able to invoke the binary produced from <code>cargo build</code> directly thanks <a href="https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html">to
<code>binfmt_misc</code></a>,
which will automatically invoke <code>qemu-riscv64</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) ./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc 
</span></span><span style="display:flex;"><span>/lib/ld-linux-riscv64-lp64d.so.1: No such file or directory
</span></span></code></pre></div><p>Hmm, that doesn&rsquo;t look great. If you remember earlier, the default behavior that
the <code>riscv64gc-unknown-linux-gnu</code> target consumed was producing a dynamically
linked executable. We can use <code>readelf</code> to see where our ELF file is <a href="https://man7.org/linux/man-pages/man8/ld.so.8.html">requesting
<code>ld-linux-riscv64-lp64d.so.1</code></a>
as its &ldquo;interpreter&rdquo;:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) riscv64-unknown-linux-gnu-readelf -l ./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  INTERP         0x0000000000000270 0x0000000000000270 0x0000000000000270
</span></span><span style="display:flex;"><span>                 0x0000000000000021 0x0000000000000021  R      0x1
</span></span><span style="display:flex;"><span>      [Requesting program interpreter: /lib/ld-linux-riscv64-lp64d.so.1]
</span></span></code></pre></div><p>When we installed our toolchain, it came with the <code>ld.so</code> dynamic linker/loader,
which you should be able to find under <code>sysroot/lib</code> in the location where you
installed your toolchain (mine is <code>~/opt/riscv</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) ls -la ~/opt/riscv/sysroot/lib/ | grep ld
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 dan dan  1120424 Jan 16 20:51 ld-2.33.so
</span></span><span style="display:flex;"><span>lrwxrwxrwx 1 dan dan       10 Jan 16 20:51 ld-linux-riscv64-lp64d.so.1 -&gt; ld-2.33.so
</span></span><span style="display:flex;"><span>drwxrwxr-x 2 dan dan    12288 Jan 16 20:31 ldscripts
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>Let&rsquo;s try invoking it with the dynamic loader:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) ~/opt/riscv/sysroot/lib/ld-linux-riscv64-lp64d.so.1 ./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc
</span></span><span style="display:flex;"><span>./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc: error while loading shared libraries: libgcc_s.so.1: cannot open shared object file: No such file or directory
</span></span></code></pre></div><p>Not quite there. One of our dynamically linked libraries, <code>libgcc_s.so</code>, can&rsquo;t
be found. While we&rsquo;re here, let&rsquo;s see all of the libraries we need to load:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) riscv64-unknown-linux-gnu-readelf -a ./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc | grep NEEDED
</span></span><span style="display:flex;"><span> 0x0000000000000001 (NEEDED)             Shared library: [libgcc_s.so.1]
</span></span><span style="display:flex;"><span> 0x0000000000000001 (NEEDED)             Shared library: [libpthread.so.0]
</span></span><span style="display:flex;"><span> 0x0000000000000001 (NEEDED)             Shared library: [libdl.so.2]
</span></span><span style="display:flex;"><span> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]
</span></span><span style="display:flex;"><span> 0x0000000000000001 (NEEDED)             Shared library: [ld-linux-riscv64-lp64d.so.1]
</span></span></code></pre></div><p>All of these libraries live alongside our dynamic loader in
<code>~/opt/riscv/sysroot/lib</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) ls -la ~/opt/riscv/sysroot/lib/ | grep -E &#39;libgcc|libpthread|libdl|libc&#39;
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 dan dan 11675800 Jan 16 20:51 libc-2.33.so
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 dan dan   148752 Jan 16 20:50 libcrypt-2.33.so
</span></span><span style="display:flex;"><span>lrwxrwxrwx 1 dan dan       16 Jan 16 20:50 libcrypt.so.1 -&gt; libcrypt-2.33.so
</span></span><span style="display:flex;"><span>lrwxrwxrwx 1 dan dan       12 Jan 16 20:50 libc.so.6 -&gt; libc-2.33.so
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 dan dan   118136 Jan 16 20:50 libdl-2.33.so
</span></span><span style="display:flex;"><span>lrwxrwxrwx 1 dan dan       13 Jan 16 20:50 libdl.so.2 -&gt; libdl-2.33.so
</span></span><span style="display:flex;"><span>-rw-r--r-- 1 dan dan      132 Jan 16 21:05 libgcc_s.so
</span></span><span style="display:flex;"><span>-rw-r--r-- 1 dan dan   599912 Jan 16 21:05 libgcc_s.so.1
</span></span><span style="display:flex;"><span>-rwxr-xr-x 1 dan dan  1214880 Jan 16 20:50 libpthread-2.33.so
</span></span><span style="display:flex;"><span>lrwxrwxrwx 1 dan dan       18 Jan 16 20:50 libpthread.so.0 -&gt; libpthread-2.33.so
</span></span></code></pre></div><p>The loader identifies shared libraries with using a cache in <code>/etc/ld.so.cache</code>
that is managed by <code>ldconfig</code> based on the contents of <code>/etc/ld.so.config</code>.
However, we can add directories at runtime that we would like to take precedence
over any in the cache using <code>LD_LIBRARY_PATH</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) LD_LIBRARY_PATH=~/opt/riscv/sysroot/lib ~/opt/riscv/sysroot/lib/ld-linux-riscv64-lp64d.so.1 --library-path ~/opt/riscv/sysroot/lib ./target/riscv64gc-unknown-linux-gnu/debug/rusty-risc
</span></span><span style="display:flex;"><span>Hello, world!
</span></span></code></pre></div><p>The program runs successfully! We could automate this to make it possible to
invoke using <code>cargo run</code> by passing <code>LD_LIBRARY_PATH</code> as a flag and setting it
as the <code>runner</code>:</p>
<blockquote>
<p>This can be cleaned up further so we aren&rsquo;t using absolute paths. Also,
remember that this working is predicated on <code>binfmt_misc</code> invoking
<code>qemu-riscv64</code> for us automatically.</p>
</blockquote>
<p><code>./.cargo/config.toml</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[build]
</span></span><span style="display:flex;"><span>target = <span style="color:#0ff;font-weight:bold">&#34;riscv64gc-unknown-linux-gnu&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[target.riscv64gc-unknown-linux-gnu]
</span></span><span style="display:flex;"><span>runner = <span style="color:#0ff;font-weight:bold">&#34;/home/dan/opt/riscv/sysroot/lib/ld-linux-riscv64-lp64d.so.1 --library-path /home/dan/opt/riscv/sysroot/lib&#34;</span>
</span></span><span style="display:flex;"><span>linker = <span style="color:#0ff;font-weight:bold">&#34;riscv64-unknown-linux-gnu-gcc&#34;</span>
</span></span></code></pre></div><p>Lastly, if we wanted to build a statically linked executable instead, we could
supply the <code>crt-static</code> flag to <code>rustc</code>:</p>
<p><code>./.cargo/config.toml</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-toml" data-lang="toml"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[build]
</span></span><span style="display:flex;"><span>target = <span style="color:#0ff;font-weight:bold">&#34;riscv64gc-unknown-linux-gnu&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[target.riscv64gc-unknown-linux-gnu]
</span></span><span style="display:flex;"><span>rustflags = [<span style="color:#0ff;font-weight:bold">&#34;-C&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;target-feature=+crt-static&#34;</span>]
</span></span><span style="display:flex;"><span>linker = <span style="color:#0ff;font-weight:bold">&#34;riscv64-unknown-linux-gnu-gcc&#34;</span>
</span></span></code></pre></div><p>To understand how this impacts compilation, we can check the flag descriptions
in <code>rustc</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) rustc -C help | grep target-features
</span></span><span style="display:flex;"><span>    -C           target-feature=val -- target specific attributes. (`rustc --print target-features` for details). This feature is unsafe.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) rustc --print target-features | grep crt-static
</span></span><span style="display:flex;"><span>    crt-static                      - Enables C Run-time Libraries to be statically linked.
</span></span></code></pre></div><p>Now let&rsquo;s see if we can run without specifying any <code>runner</code> at all:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) cargo build
</span></span><span style="display:flex;"><span>   Compiling rusty-risc v0.1.0 (/home/dan/code/github.com/hasheddan/testing/rusty-risc)
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized + debuginfo] target(s) in 2.40s
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>$ (rusty-risc) cargo run
</span></span><span style="display:flex;"><span>    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
</span></span><span style="display:flex;"><span>     Running `target/riscv64gc-unknown-linux-gnu/debug/rusty-risc`
</span></span><span style="display:flex;"><span>Hello, world!
</span></span></code></pre></div><p>Nice! We can now build both statically and dynamically linked Rust binaries for
RISC-V Linux platforms.</p>
<h2 id="concluding-thoughts">
  Concluding Thoughts
  <a class="heading-link" href="#concluding-thoughts">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>This post was a bit of a deviation from our normal content, but I am a big fan
of Rust and naturally enjoy when I see more folks producing RISC-V builds.
Hopefully centralizing some of this information will make it easier for folks to
pick up.</p>
<p>As always, these posts are meant to serve as a useful resource for folks who are
interested in learning more about RISC-V and low-level software in general. If I
can do a better job of reaching that goal, or you have any questions or
comments, please feel free to send me a message
<a href="https://twitter.com/hasheddan">@hasheddan</a> on Twitter!</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
    2026
     Daniel Mangum 
    ·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://danielmangum.com/js/coder.min.27afce394fb6284f521b3fbc9f6a8326342333c3092267f3944d770489876fed.js" integrity="sha256-J6/OOU&#43;2KE9SGz&#43;8n2qDJjQjM8MJImfzlE13BImHb&#43;0="></script>
  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-116820283-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  

  

  

  

  

  

  
</body>

</html>
