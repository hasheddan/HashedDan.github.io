<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  RISC-V Bytes: Privilege Levels Â· Daniel Mangum
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Daniel Mangum">
<meta name="description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
It has been a bit since our last post, but today we are going to begin our journey into some of the more interesting areas of RISC-V systems. In the first post in the series, we installed our RISC-V toolchain, which included QEMU.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RISC-V Bytes: Privilege Levels"/>
<meta name="twitter:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
It has been a bit since our last post, but today we are going to begin our journey into some of the more interesting areas of RISC-V systems. In the first post in the series, we installed our RISC-V toolchain, which included QEMU."/>

<meta property="og:title" content="RISC-V Bytes: Privilege Levels" />
<meta property="og:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
It has been a bit since our last post, but today we are going to begin our journey into some of the more interesting areas of RISC-V systems. In the first post in the series, we installed our RISC-V toolchain, which included QEMU." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://danielmangum.com/posts/risc-v-bytes-privilege-levels/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-27T00:10:34-06:00" />
<meta property="article:modified_time" content="2021-12-27T00:10:34-06:00" />




<link rel="canonical" href="https://danielmangum.com/posts/risc-v-bytes-privilege-levels/">


<link rel="preload" href="https://danielmangum.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://danielmangum.com/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css" integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin="anonymous" media="screen" />








 




<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://danielmangum.com/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://danielmangum.com/images/apple-touch-icon.png">

<link rel="manifest" href="https://danielmangum.com/site.webmanifest">
<link rel="mask-icon" href="https://danielmangum.com/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.109.0">





  </head>




<body class="preload-transitions colorscheme-light">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://danielmangum.com/">
      Daniel Mangum
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/categories/risc-v-bytes/">[RISC-V Bytes]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/risc-v-tips/">[RISC-V Tips]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/posts/">[Blog]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/about/">[About]</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://danielmangum.com/posts/risc-v-bytes-privilege-levels/">
              RISC-V Bytes: Privilege Levels
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2021-12-27T00:10:34-06:00">
                December 27, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              22-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="https://danielmangum.com/categories/risc-v-bytes/">RISC-V Bytes</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
        <blockquote>
<p>This is part of a series on the blog where we explore
<a href="https://riscv.org/">RISC-V</a> by breaking down real programs and explaining how
they work. You can view all posts in this series on the <a href="https://danielmangum.com/categories/risc-v-bytes">RISC-V Bytes
page</a>.</p>
</blockquote>
<p><img src="../../static/risc_v_priv_levels_1.png" alt="risc-v-priv-levels-1"></p>
<p>It has been a bit since our last post, but today we are going to begin our
journey into some of the more interesting areas of RISC-V systems. In the <a href="https://danielmangum.com/posts/risc-v-bytes-qemu-gdb/">first
post in the series</a>, we
installed our RISC-V toolchain, which included <a href="https://www.qemu.org/">QEMU</a>. We
denoted at that point that three RISC-V QEMU binaries were actually installed:</p>
<ul>
<li><code>qemu-riscv32</code></li>
<li><code>qemu-riscv64</code></li>
<li><code>qemu-system-riscv64</code></li>
</ul>
<p>Most software developers are at least somewhat familiar with the concept of
privilege on a computer. For example, the operating system is able to perform
operations that are prohibited for processes running in user space. This allows
for isolation and protection; a single process is not able to access the memory
of another, and a process that crashes does not corrupt the entire system. To
enable this model, hardware must offer varying levels of privilege and the
ability to move between them.</p>
<p>In previous posts we have used <code>qemu-riscv64</code> to emulate processes running in
user space. <code>qemu-system-riscv64</code> gives us full system emulation, meaning that
we can access all privilege modes, which is useful when testing software that
runs at lower levels of the stack. In order to understand how software makes use
of these privilege levels, we need to take a step back and examine what RISC-V
systems actually offer.</p>
<h2 id="risc-v-privilege-levels">
  RISC-V Privilege Levels
  <a class="heading-link" href="#risc-v-privilege-levels">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Volume 2 of the <a href="https://riscv.org/technical/specifications/">RISC-V ISA
specification</a>, or &ldquo;The Privileged
Spec&rdquo;, defines offered privilege levels. In simplest terms, RISC-V offers three
levels of privilege, or <em>modes</em>, which systems can choose to support in
different configurations. The three basic modes include:</p>
<ul>
<li><code>Machine (M)</code></li>
<li><code>Supervisor (S)</code></li>
<li><code>User (U)</code></li>
</ul>
<p>These modes are listed in order of <em>decreasing privilege</em>, with <code>Machine (M)</code>
mode being the most privileged and <code>User (U)</code> mode being the least. All RISC-V
systems <em>must</em> implement <code>M</code> mode, but may optionally support <code>S</code> mode and <code>U</code>
mode. This allows for the following configurations:</p>
<ul>
<li><code>M</code></li>
<li><code>M</code> and <code>U</code></li>
<li><code>M</code>, <code>S</code>, and <code>U</code></li>
</ul>
<p>Systems choose to support modes based on the complexity of the software they
will run. A small device that only runs a single, trusted application may choose
to only support <code>M</code> mode. If there is desire for an isolation boundary between
the application and more direct hardware access, <code>M</code> and <code>U</code> mode may both be
supported. A robust system, such as a server or desktop machine will support
<code>M</code>, <code>S</code>, and <code>U</code> for the benefits enumerated in the introduction.</p>
<blockquote>
<p>In the latest versions of the Privileged Spec, the Hypervisor (H) extension
has reached v1.0 and has been ratified. This allows for <code>S</code> mode to be
extended with additional virtualization capabilities, resulting in privilege
modes for <code>Hypervisor-extended Supervisor (HS)</code>, <code>Virtual Supervisor (VS)</code>,
and <code>Virtual User (VU)</code>. This mode will be covered in more detail in a future
post.</p>
</blockquote>
<blockquote>
<p>The Privileged Spec also references <code>Debug (D)</code> mode, which has its own
<a href="https://github.com/riscv/riscv-debug-spec">dedicated specification</a>. <code>D</code> mode
offers even higher privilege than <code>M</code> mode. In my opinion, this is one of the
most interesting components of the RISC-V ecosystem, and I will certainly be
sharing some more about it soon.</p>
</blockquote>
<h2 id="control-and-status-registers-csrs">
  Control and Status Registers (CSRs)
  <a class="heading-link" href="#control-and-status-registers-csrs">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>In our post on <a href="https://danielmangum.com/posts/risc-v-bytes-caller-callee-registers/">Caller and Callee Saved
Registers</a>,
we introduced 32 <em>General Purpose Registers (GPRs)</em> defined in the RISC-V ISA.
These registers are defined in the Unprivileged Spec and are sometimes referred
to as <em>integer registers</em>. The RISC-V Privileged Spec defines additional
registers referred to as <em>Control and Status Registers (CSRs)</em>. While GPRs are
accessible at any privilege level, CSRs are defined at a specific privilege
level and can only be accessed by that level and any levels of higher privilege.</p>
<p>The Privileged Spec defines both a common set of CSRs and address ranges that
all CSRs must reside within. CSR addresses are 12-bits, meaning that up to 4,096
CSRs can be implemented (<code>2^12 = 4096</code>). The bits in a CSR address define its
accessibility, use, and CSR number.</p>
<p><img src="../../static/risc_v_priv_levels_2.png" alt="risc-v-priv-levels-2"></p>
<p>While GPRs are used for storing data used to perform operations, CSRs typically
modify the behavior of a hart (i.e. &ldquo;Control&rdquo;) or inform of its state and
attributes (i.e. &ldquo;Status&rdquo;), or both.</p>
<blockquote>
<p>Reminder: <strong>hart</strong> is a term used by RISC-V that refers to a <strong>HARdware
Thread</strong>. A hart is frequently referred to as a core or CPU in other contexts.</p>
</blockquote>
<p>The Machine Architecture ID register (<code>marchid</code>) is an example of a CSR that
only communicates information about a hart, while a CSR like Machine Trap-Vector
Base-Address Register (<code>mtvec</code>), which we will take a closer look at in this
post, modifies the hart&rsquo;s behavior.</p>
<p>While exploring CSRs warrants many individual posts, we introduce them here
because some of them are relevant to how we navigate the privilege levels
offered by a RISC-V system.</p>
<h2 id="privileged-instructions">
  Privileged Instructions
  <a class="heading-link" href="#privileged-instructions">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>In our <a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats/">Introduction to Instruction
Formats</a>
post we covered a few instructions offered by the RISC-V base ISAs, and touched
briefly on how RISC-V uses an extension model to optionally add instructions and
capabilities to a system. As part of the base ISAs, two instructions we did not
cover are defined:</p>
<ul>
<li>Environment Call (<code>ecall</code>)</li>
<li>Environment Break (<code>ebreak</code>)</li>
</ul>
<p><img src="../../static/risc_v_priv_levels_3.png" alt="risc-v-priv-levels-3"></p>
<p>These instructions are defined in the Unprivileged Spec, but fall into a
category of instructions that use the <code>SYSTEM</code> opcode, indicating that they may
require privileged access to execute successfully. The only other <code>SYSTEM</code>
instructions that are defined in the Unprivileged Spec fall under the <code>Zicsr</code>
extension:</p>
<ul>
<li>Atomic Read/Write CSR (<code>csrrw</code>)</li>
<li>Atomic Read and Set Bits in CSR (<code>csrrs</code>)</li>
<li>Atomic Read and Clear Bits in CSR (<code>csrrc</code>)</li>
<li>Atomic Read/Write CSR Immediate (<code>csrrwi</code>)</li>
<li>Atomic Read and Set Bits in CSR Immediate (<code>csrrsi</code>)</li>
<li>Atomic Read and Clear Bits in CSR Immediate (<code>csrrci</code>)</li>
</ul>
<p><img src="../../static/risc_v_priv_levels_4.png" alt="risc-v-priv-levels-4"></p>
<p>You&rsquo;ll notice that the second group of three instructions are <em>immediate</em>
variants of the first group, meaning that <code>rs1</code> is not a source register, but
rather the lowest 5 bits of an unsigned immediate value. These instructions are
used to operate on CSRs that are accessible in the current privilege level.
Throughout this post, we will primarily use <a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/b01f83328a8176a7351402414b14a0ac9bd1802f/riscv-asm.md#pseudoinstructions-for-accessing-control-and-status-registers">CSR
pseudoinstructions</a>
to interact with CSRs, which have the following mapping to the instructions
defined above:</p>
<ul>
<li><code>csrr rd, rs</code> -&gt; <code>csrrs rd, csr, x0</code></li>
<li><code>csrw csr, rs</code> -&gt; <code>csrrw x0, csr, rs</code></li>
<li><code>csrs csr, rs</code> -&gt; <code>csrrs x0, csr, rs</code></li>
<li><code>csrc csr, rs</code> -&gt; <code>csrrc x0, csr, rs</code></li>
<li><code>csrwi csr, imm</code> -&gt; <code>csrrwi x0, csr, imm</code></li>
<li><code>csrsi csr, imm</code> -&gt; <code>csrrsi x0, csr, imm</code></li>
<li><code>csrci csr, imm</code> -&gt; <code>csrrci x0, csr, imm</code></li>
</ul>
<p>The Privileged Spec defines additional <code>SYSTEM</code> instructions per privilege
level, but we will only use two of them in this post:</p>
<ul>
<li>Machine Return from Trap (<code>mret</code>)</li>
<li>Supervisor Return from Trap (<code>sret</code>)</li>
</ul>
<p><img src="../../static/risc_v_priv_levels_5.png" alt="risc-v-priv-levels-5"></p>
<p>The <code>Zicsr</code> instructions are somewhat self-explanatory, but the environment and
trap instructions require further investigation. When a RISC-V hart starts it is
in <code>M</code> mode. In order to navigate between privilege levels, we need to be able
to both request a <em>trap</em> and return from one. <code>ecall</code> is the primary mechanism
for requesting a <a href="https://danielmangum.com/risc-v-tips/2021-12-22-trap-precision/">precise
trap</a>. A good
example of when <code>ecall</code> is used in practice is with <em>system calls (syscalls)</em>.
When a user space (<code>U</code> mode) process needs a privileged operation to be
performed on its behalf, it stores information about the request according to
calling conventions, then issues an <code>ecall</code> instruction to trap to <code>S</code> mode.
Typically the operating system kernel is running in <code>S</code> mode and has registered
<em>trap handlers</em> to respond when these requests are made. After servicing the
request, the kernel wants to return control back to the user space process, so
it issues an <code>sret</code> instruction. Let&rsquo;s see how this works in practice.</p>
<h2 id="getting-set-up">
  Getting Set Up
  <a class="heading-link" href="#getting-set-up">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>As previously mentioned, a hart starts out in <code>M</code> mode. We can break out QEMU to
see this in action, but first we&rsquo;ll need to write a program to step through. In
previous posts we have written C code and examined the output of the compiler.
Though C is a fairly minimal language, it still requires setting up a stack, so
we are going to write RISC-V assembly directly, and use the assembler and linker
available in our RISC-V GCC toolchain.</p>
<p><code>entry.S</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>.section .text
</span></span><span style="display:flex;"><span>.globl start
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>start:
</span></span><span style="display:flex;"><span>    la      t0, supervisor
</span></span><span style="display:flex;"><span>    csrw    mepc, t0
</span></span><span style="display:flex;"><span>    la      t1, m_trap
</span></span><span style="display:flex;"><span>    csrw    mtvec, t1
</span></span><span style="display:flex;"><span>    li      t2, 0x1800
</span></span><span style="display:flex;"><span>    csrc    mstatus, t2
</span></span><span style="display:flex;"><span>    li      t3, 0x800
</span></span><span style="display:flex;"><span>    csrs    mstatus, t3
</span></span><span style="display:flex;"><span>    li      t4, 0x100
</span></span><span style="display:flex;"><span>    csrs    medeleg, t4
</span></span><span style="display:flex;"><span>    mret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>m_trap:
</span></span><span style="display:flex;"><span>    csrr    t0, mepc
</span></span><span style="display:flex;"><span>    csrr    t1, mcause
</span></span><span style="display:flex;"><span>    la      t2, supervisor
</span></span><span style="display:flex;"><span>    csrw    mepc, t2
</span></span><span style="display:flex;"><span>    mret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>supervisor:
</span></span><span style="display:flex;"><span>    la      t0, user
</span></span><span style="display:flex;"><span>    csrw    sepc, t0
</span></span><span style="display:flex;"><span>    la      t1, s_trap
</span></span><span style="display:flex;"><span>    csrw    stvec, t1
</span></span><span style="display:flex;"><span>    sret
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>s_trap:
</span></span><span style="display:flex;"><span>    csrr    t0, sepc
</span></span><span style="display:flex;"><span>    csrr    t1, scause
</span></span><span style="display:flex;"><span>    ecall
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>user:
</span></span><span style="display:flex;"><span>    csrr    t0, instret
</span></span><span style="display:flex;"><span>    ecall
</span></span></code></pre></div><p>Since we don&rsquo;t have the benefit of an operating system already being in place,
we are also going to need to provide our own linker script that specifies where
our code should exist in memory. Perhaps the simplest linker script we can use
would look like the following:</p>
<p><code>virt.ld</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>SECTIONS
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  . = 0x80000000;
</span></span><span style="display:flex;"><span>  .text : { *(.text) }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>This is a <em>very</em> simple linker script that will work for our use case here,
but is likely not suitable for any meaningful scenario. The purpose of such a
minimal linker script is for any reader to be able to understand exactly how
we are constructing our ELF file without needing to have extensive knowledge
of linker scripts. Linkers are a wild and fascinating world that we will
explore more soon!</p>
</blockquote>
<p>All we are saying is to take the <code>.text</code> sections from all input object files we
provide to the linker and combine them into our output executable <code>.text</code>
section at address <code>0x80000000</code>, which is where the <code>virt</code> machine we are going
to use with QEMU <a href="https://github.com/qemu/qemu/blob/1bd88c4542e97f49955c142f8dc04dd32df9e91f/hw/riscv/virt.c#L60">maps its
DRAM</a>.
Since we will only provide one file as input, the code in <code>entry.S</code> will be
loaded into memory at <code>0x80000000</code> and <code>start</code> will be used as the entry point
(<code>ld</code> defaults to setting the entry point to <code>start</code> symbol <a href="https://danielmangum.com/risc-v-tips/2021-12-23-ld-default-entry-point/">if present and not
otherwise
specified</a>).
Let&rsquo;s go ahead and assemble and link our program:</p>
<p>Assemble: <code>riscv64-unknown-elf-as entry.S -o entry.o</code></p>
<p>Link: <code>riscv64-unknown-elf-ld -Tvirt.ld entry.o -o entry</code></p>
<p>Now let&rsquo;s walk through what it&rsquo;s actually doing. We can run QEMU and attach to
it, similarly to the steps we took when debugging user space programs, but we&rsquo;ll
need to provide some additional arguments this time:</p>
<p><code>qemu-system-riscv64 -machine virt -cpu rv64 -smp 1 -s -S -nographic -bios none -kernel entry</code></p>
<p>Here we are specifying:</p>
<ul>
<li>Use the QEMU virtual machine as our emulation target (<code>-machine virt</code>)</li>
<li>Use the generic <code>rv64</code> CPU architecture (<code>cpu rv64</code>)</li>
<li>Run with a single hart (<code>-smp 1</code>)</li>
<li>Run as a <code>gdbstub</code> (<code>-s</code> is shorthand for <code>-gdb tcp::1234</code>)</li>
<li>Wait for command before starting execution (<code>-S</code>)</li>
<li>Do not display a graphical interface (<code>-nographic</code>)</li>
<li>The combination of <code>-bios none</code> and <code>-kernel entry</code> is somewhat more opaque
than the other options, but it is essentially saying &ldquo;load this ELF file into
memory and start execution&rdquo;. In the context of RISC-V, it means that we are
not running with <a href="https://github.com/riscv-software-src/opensbi">OpenSBI</a>
enabled.</li>
</ul>
<p>In a separate session we can run GDB and attach to our running QEMU instance:</p>
<p><code>riscv64-unknown-elf-gdb entry -ex &quot;target remote :1234&quot;</code></p>
<p>We&rsquo;ll be dropped into our familiar GDB shell, where we can do some initial setup
that will make navigating program execution easier:</p>
<ol>
<li>I like to set the program counter (<code>$pc</code>) to be displayed on every step in
instruction (<code>/i</code>) format:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(gdb) display /i $pc
</span></span></code></pre></div><ol start="2">
<li>We&rsquo;ll mostly be stepping through our program, but it can be helpful to set
breakpoints at points of interest. Let&rsquo;s do so for each symbol we defined:</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) b *start
</span></span><span style="display:flex;"><span>(gdb) b *m_trap
</span></span><span style="display:flex;"><span>(gdb) b *supervisor
</span></span><span style="display:flex;"><span>(gdb) b *s_trap
</span></span><span style="display:flex;"><span>(gdb) b *user
</span></span></code></pre></div><blockquote>
<p>Prefixing symbols with <code>*</code> tells GDB that we want to break at the exact
address of the symbol. If we do not provide <code>*</code> GDB will attempt to &ldquo;guess&rdquo;
where the function prologue ends and set the breakpoint there instead. You can
try this out by setting a breakpoint using <code>b start</code>, for example.</p>
</blockquote>
<ol start="3">
<li>There are a couple of CSRs that will be of interest throughout execution. We
can set them to print on every step in hexadecimal (<code>/x</code>):</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) display /x $mstatus
</span></span><span style="display:flex;"><span>(gdb) display /x $mepc
</span></span><span style="display:flex;"><span>(gdb) display /x $sstatus
</span></span><span style="display:flex;"><span>(gdb) display /x $sepc
</span></span></code></pre></div><p>These are not the only CSRs that we will interact with, but they are the ones
that will be changed by the system without us explicitly writing to them. Feel
free to add any other CSRs or registers you want to see on every step.</p>
<p>We are now ready to step through our program.</p>
<h2 id="changing-privilege-modes">
  Changing Privilege Modes
  <a class="heading-link" href="#changing-privilege-modes">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>As previously mentioned, our entry point is defined as <code>start</code>, which is at
address <code>0x80000000</code> in memory. QEMU will jump there after some initial setup,
and since we already set a breakpoint, we can issue a &ldquo;continue&rdquo; (<code>c</code>) command
and GDB will stop and return control to us at the symbol:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 1, 0x0000000080000000 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000000 &lt;start&gt;:  auipc   t0,0x0
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x0
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span></code></pre></div><p>As you can see, we have a nice view of some of the CSRs, all of which are zeroed
out initially, as well as the next instruction that will execute (i.e. the
current address stored in <code>pc</code>). So why is the first instruction different than
the <code>la t0, supervisor</code> we specified? Load address (<code>la</code>) is actually a
pseudoinstruction that abstracts loading the address of a specific symbol into a
GPR. It both allows us to reference a symbol by name, and avoid having to
manually perform the two-step process of loading a wide address into a register.</p>
<blockquote>
<p>A <em>wide address</em> just refers to one that is too large for a single immediate
value instruction (i.e. cannot be represented in 12 bits).</p>
</blockquote>
<p>We can see that the assembler has translated our <code>la</code> psuedoinstruction into an
<code>auipc</code> / <code>addi</code> sequence:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/2i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000000 &lt;start&gt;:      auipc   t0,0x0
</span></span><span style="display:flex;"><span>   0x80000004 &lt;start+4&gt;:    addi    t0,t0,84
</span></span></code></pre></div><p>The <code>auipc</code> instruction is &ldquo;<code>pc</code>-relative&rdquo;, meaning that it is going to build an
address by applying an offset to the current <code>pc</code>. The supplied immediate
(<code>0x0</code>) is used for the top 20 bits of the offset, and the bottom 12 bits are
filled in with <code>0</code>. In our case, since the <code>supervisor</code> symbol is close by, the
<code>auipc</code> instruction is essentially just storing the <code>pc</code> (offset = <code>0</code>). We can
see the address we are trying to store in <code>t0</code> by printing the <code>supervisor</code>
symbol:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) p supervisor 
</span></span><span style="display:flex;"><span>$1 = {&lt;text variable, no debug info&gt;} 0x80000054 &lt;supervisor&gt;
</span></span></code></pre></div><blockquote>
<p>We are debugging the final executable in this post, but if you are interested
in how the final address for a symbol such as <code>supervisor</code> gets resolved to
the one we see above, check out this terrific post by Palmer Dabbelt on
<a href="https://www.sifive.com/blog/all-aboard-part-2-relocations">RISC-V ELF
Relocations</a>.</p>
</blockquote>
<p>If we step into (<code>si</code>) our <code>auipc</code> instruction, we should see that <code>t0</code> equals
the value of <code>pc</code> when the instruction was executed.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si
</span></span><span style="display:flex;"><span>0x0000000080000004 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000004 &lt;start+4&gt;:    addi    t0,t0,84
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x0
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span><span style="display:flex;"><span>(gdb) p /x $t0
</span></span><span style="display:flex;"><span>$2 = 0x80000000
</span></span></code></pre></div><p>We have effectively set the &ldquo;top bits&rdquo; (most significant) of our address, and we
can now set the &ldquo;bottom bits&rdquo; (least significant). Doing so is as easy as
performing addition with an immediate and the contents of <code>t0</code> (<code>addi</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si
</span></span><span style="display:flex;"><span>0x0000000080000008 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000008 &lt;start+8&gt;:    csrw    mepc,t0
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x0
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span><span style="display:flex;"><span>(gdb) p /x $t0            
</span></span><span style="display:flex;"><span>$3 = 0x80000054
</span></span></code></pre></div><p>The address of <code>supervisor</code> is now in <code>t0</code>, and we can see that the next
instruction will use the <code>csrw</code> pseudoinstruction to write the address to
<code>mepc</code>, the <em>Machine Exception Program Counter</em>. This CSR is used to instruct
the processor where execution should continue when returning from a trap in <code>M</code>
mode (using the <code>mret</code> instruction we saw earlier). Typically <code>mepc</code> will be
automatically updated to the address of the current instruction when an
exception or interrupt occurs, but since we are starting in <code>M</code> mode and want to
specify where execution should continue when we jump to <code>S</code> mode, we must
manually set it.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x000000008000000c in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x8000000c &lt;start+12&gt;:   auipc   t1,0x0
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span></code></pre></div><p>Our handy CSR displays show us that <code>mepc</code> now contains the address of
<code>supervisor</code>. Next we do the same sequence to load the address of <code>m_trap</code> into
the <em>Machine Trap Vector</em> (<code>mtvec</code>) CSR. This CSR instructs the processor where
to continue execution when a trap occurs. You may have heard the bit of code we
have at <code>m_trap</code> referred to as a &ldquo;trap handler&rdquo;. In an operating system, trap
handlers (typically in <code>S</code> mode) are how syscalls and related functionality are
implemented. Let&rsquo;s step through these instructions and ensure that <code>mtvec</code>
contains the address of <code>m_trap</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) p m_trap
</span></span><span style="display:flex;"><span>$4 = {&lt;text variable, no debug info&gt;} 0x8000003c &lt;m_trap&gt;
</span></span><span style="display:flex;"><span>(gdb) si 3
</span></span><span style="display:flex;"><span>0x0000000080000018 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000018 &lt;start+24&gt;:   lui t2,0x2
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span><span style="display:flex;"><span>(gdb) p /x $mtvec
</span></span><span style="display:flex;"><span>$5 = 0x8000003c
</span></span></code></pre></div><p>Looks good! Our next sequence is slightly more complicated. We once again used a
pseudoinstruction (<code>li</code>) to avoid having to manually load a wide immediate
(<code>0x1800</code> = <code>1100000000000</code>, which requires more than 12 bits), but we aren&rsquo;t
just specifying an address in this case. The 11th and 12th bits in the <code>mstatus</code>
CSR specify the <em>Machine Previous Privilege</em>, or MPP for short. Similar to
<code>mepc</code>, these bits are typically set automatically when a trap to <code>M</code> mode
occurs, but since we are already in <code>M</code> mode and we did not come from a
different privilege level, we need to set it to the privilege level we want to
return to when we issue the <code>mret</code> instruction. Each mode in a RISC-V system is
represented by a two bit encoding:</p>
<ul>
<li><code>M</code> -&gt; <code>11</code></li>
<li><code>S</code> -&gt; <code>01</code></li>
<li><code>U</code> -&gt; <code>00</code></li>
</ul>
<p>We can see from our previous steps that <code>mstatus</code> is currently <code>0x0</code>, indicating
that MPP is set to <code>00</code>, or <code>U</code> mode. We want to jump to <code>S</code> mode rather than
<code>U</code> mode, so we need to set the 11th and 12th bits to <code>01</code>. However, we don&rsquo;t
want to touch the other bits in <code>mstatus</code>, so it&rsquo;s not as simple as just writing
<code>0x1800</code>. Instead, we will make use of <em>bit masks</em> and the properties of logical
<code>AND</code> and <code>OR</code> operations. To understand how this works, let&rsquo;s first define
those properties:</p>
<hr>
<p><strong><code>AND 1</code> Preserves a Bit</strong></p>
<p>Taking any bit and performing an <code>AND 1</code> operation will not change the bit.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0 AND 1 = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1 AND 1 = 1
</span></span></code></pre></div><p><strong><code>AND 0</code> Clears a Bit</strong></p>
<p>Taking any bit and performing an <code>AND 0</code> operation will result in <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0 AND 0 = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1 AND 0 = 0
</span></span></code></pre></div><p><strong><code>OR 0</code> Preserves a Bit</strong></p>
<p>Taking any bit and performing an <code>OR 0</code> operation will not change the bit.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0 OR 0 = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1 OR 0 = 1
</span></span></code></pre></div><p><strong><code>OR 1</code> Sets a Bit</strong></p>
<p>Taking any bit and performing an <code>OR 1</code> operation will result in <code>1</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0 OR 1 = 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>1 OR 1 = 1
</span></span></code></pre></div><hr>
<p>Fortunately, we have convenient psuedoinstructions, <code>csrc</code> and <code>csrs</code>, that help
us utilize these properties to set specific bits generically within a CSR. In
this case, we are going to clear the 11th and 12th bit, which wouldn&rsquo;t strictly
be required in this case as they are already <code>00</code>, then set them to <code>01</code>.</p>
<p><img src="../../static/risc_v_priv_levels_6.png" alt="risc-v-priv-levels-6"></p>
<p>Let&rsquo;s step into both operations to demonstrate:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si 3
</span></span><span style="display:flex;"><span>0x0000000080000024 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000024 &lt;start+36&gt;:   lui t3,0x1
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span><span style="display:flex;"><span>(gdb) si 3
</span></span><span style="display:flex;"><span>0x0000000080000030 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000030 &lt;start+48&gt;:   li  t4,256
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x800
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span></code></pre></div><p>Our first sequence of instructions cause no change to <code>mstatus</code> as we are
clearing bits that are already <code>0</code>, but the next sequence shows that we have now
set the 11th and 12th bits to <code>01</code>.</p>
<blockquote>
<p>The fact that <code>mstatus = 0x800</code>, the immediate we used to set the bits is just
a result of it initially being <code>0x0</code>. If other bits had been set in <code>mstatus</code>
the immediate we passed to <code>csrs</code> would not be the same as the final contents
of <code>mstatus</code>.</p>
</blockquote>
<p>We have one more sequence of instructions before we jump to <code>S</code> mode. By
default, all exceptions and interrupts are handled in <code>M</code> mode, but in a system
that supports <code>S</code> and <code>U</code> modes, we may want to delegate some exceptions to <code>S</code>
mode. For example, in this program we are going to delegate environment calls
(<code>ecall</code>) from <code>U</code> mode to <code>S</code> mode. We can do so by setting the 8th bit in the
<code>medeleg</code> <em>Machine Trap Delegation</em> CSR.</p>
<p><img src="../../static/risc-v-tips/21-11-15.png" alt="risc-v-tips-21-11-15"></p>
<blockquote>
<p>There is a separate <code>mideleg</code> CSR for delegating interrupts.</p>
</blockquote>
<p>To do so, we&rsquo;ll again use our CSR bit manipulation instructions, but because we
are only setting a single bit, we don&rsquo;t have to worry about clearing it first
(no matter what the bit&rsquo;s current value is, we want it to be <code>1</code>, which is the
behavior of <code>OR 1</code>). An interesting thing to note here is that our <code>li</code>
pseudoinstruction was not broken into a <code>lui</code> / <code>addiw</code> sequence like it was
before. This is due to the fact that our immediate value (<code>0x100</code> = <code>256</code> =
<code>100000000</code>) can fit into the 12 bits allowed in an <code>I</code> format instruction. If
we actually examind the binary representation of our <code>li</code> instruction, we can
see that under the hood it is an <code>addi</code> (opcode: <code>0010011</code>, rd: <code>11101 = 29 = t4</code>, funct3: <code>000</code>, rs1: <code>00000 = 0 = zero</code>, immediate: <code>000100000000 = 256</code>):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/t $pc    
</span></span><span style="display:flex;"><span>0x80000030 &lt;start+48&gt;:  00010000000000000000111010010011
</span></span></code></pre></div><p>Stepping through the sequence ensures the 8th bit of <code>medeleg</code> is <code>1</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si 2
</span></span><span style="display:flex;"><span>0x0000000080000038 in start ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000038 &lt;start+56&gt;:   mret
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x800
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span><span style="display:flex;"><span>(gdb) p /t $medeleg
</span></span><span style="display:flex;"><span>$6 = 100000000
</span></span></code></pre></div><p>We are finally ready to return, and we should see execution jump to
<code>supervisor</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 3, 0x0000000080000054 in supervisor ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000054 &lt;supervisor&gt;: auipc   t0,0x0
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x80
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x0
</span></span></code></pre></div><h2 id="handling-traps">
  Handling Traps
  <a class="heading-link" href="#handling-traps">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>The remainder of our program will just move us up and down our privilege levels
forever, never performing any meaningful work. However, there are a few more
concepts that are worth mentioning before we finish out. Our <code>supervisor</code>
instructions perform similar operations those in <code>start</code>, but this time using
the corresponding <code>S</code> mode CSRs, setting the exception program counter (<code>sepc</code>)
to the address of the <code>user</code> symbol, and setting the <code>S</code> mode trap vector
(<code>stvec</code>) to the address of the <code>s_trap</code> symbol.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) disass supervisor
</span></span><span style="display:flex;"><span>Dump of assembler code for function supervisor:
</span></span><span style="display:flex;"><span>=&gt; 0x0000000080000054 &lt;+0&gt;:     auipc   t0,0x0
</span></span><span style="display:flex;"><span>   0x0000000080000058 &lt;+4&gt;:     addi    t0,t0,40 # 0x8000007c &lt;user&gt;
</span></span><span style="display:flex;"><span>   0x000000008000005c &lt;+8&gt;:     csrw    sepc,t0
</span></span><span style="display:flex;"><span>   0x0000000080000060 &lt;+12&gt;:    auipc   t1,0x0
</span></span><span style="display:flex;"><span>   0x0000000080000064 &lt;+16&gt;:    addi    t1,t1,16 # 0x80000070 &lt;s_trap&gt;
</span></span><span style="display:flex;"><span>   0x0000000080000068 &lt;+20&gt;:    csrw    stvec,t1
</span></span><span style="display:flex;"><span>   0x000000008000006c &lt;+24&gt;:    sret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span></code></pre></div><p>If we continue (<code>c</code>) we should see the first breakpoint we hit to be at <code>user</code>,
which is where execution continues after <code>sret</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 5, 0x000000008000007c in user ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x8000007c &lt;user&gt;:   rdinstret   t0
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0xa0
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x20
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x8000007c
</span></span></code></pre></div><p>Now that we are in <code>U</code> mode, we read the <code>instret</code> CSR, which counts the number
of instructions retired for the hart, for fun to demonstrate that it is one of
the few CSRs we can access from <code>U</code> mode (also note that the assembler
conveniently transformed our <code>csrr    t0, instret</code> into the <code>rdinstret</code>
pseudoinstrection). Then we issue the <code>ecall</code> instruction, which we previously
delegated to be handled by <code>S</code> mode. If we continue (<code>c</code>), we should hit the
breakpoint we set at <code>s_trap</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 4, 0x0000000080000070 in s_trap ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x80000070 &lt;s_trap&gt;: csrr    t0,sepc
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x80
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000054
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x80000080
</span></span></code></pre></div><p>In <code>s_trap</code> we read the <code>sepc</code> and <code>scause</code> CSRs. We previously mentioned that
<code>sepc</code> should be updated to the instruction that caused the trap. If we examine
the address it contains, it will point to our <code>U</code> mode <code>ecall</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/i 0x80000080  
</span></span><span style="display:flex;"><span>0x80000080 &lt;user+4&gt;: ecall
</span></span></code></pre></div><p>We haven&rsquo;t talked about <code>scause</code> and <code>mcause</code> quite yet, but they do what you
might expect: inform what caused the trap. They use the same exception and
interrupt encodings that <code>medeleg</code> / <code>mideleg</code> are based off of, so we would
expect the value of <code>scause</code> to be <code>8</code> (corresponding to how we used the 8th bit
in <code>medeleg</code> to delegate environment call from <code>U</code> mode).</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) i r scause
</span></span><span style="display:flex;"><span>scause         0x8  8
</span></span></code></pre></div><p>Lastly, we issue an <code>ecall</code> from <code>S</code> mode, which should cause us to trap to <code>M</code>
mode and continue execution at <code>m_trap</code>. In <code>m_trap</code> we read the corresponding
CSRs (<code>mepc</code> / <code>mcause</code>) before overwriting the <code>mepc</code> with the address of
<code>supervisor</code> so that we will return there with <code>mret</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) c
</span></span><span style="display:flex;"><span>Continuing.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Breakpoint 2, 0x000000008000003c in m_trap ()
</span></span><span style="display:flex;"><span>1: x/i $pc
</span></span><span style="display:flex;"><span>=&gt; 0x8000003c &lt;m_trap&gt;: csrr    t0,mepc
</span></span><span style="display:flex;"><span>2: /x $mstatus = 0x800
</span></span><span style="display:flex;"><span>3: /x $mepc = 0x80000078
</span></span><span style="display:flex;"><span>4: /x $sstatus = 0x0
</span></span><span style="display:flex;"><span>5: /x $sepc = 0x80000080
</span></span></code></pre></div><p>If you keep continuing through the program you will notice that it is structured
to jump up and down the privilege levels forever.</p>
<h2 id="concluding-thoughts">
  Concluding Thoughts
  <a class="heading-link" href="#concluding-thoughts">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>While we only performed trivial operations in each privilege level throughout
this post, the capabilities the hardware offers to systems software has started
to become apparent. Now that we know how to move between privilege levels we can
start to build out higher level abstractions on top of the primitives. In future
posts we&rsquo;ll explore some common abstractions that popular operating systems
offer, as well as other primitives that the hardware offers, such as <a href="https://danielmangum.com/risc-v-tips/2021-11-16-physical-memory-protection/">Physical
Memory Protection
(PMP)</a>
and <a href="https://danielmangum.com/risc-v-tips/2021-11-21-virtual-memory-addressing-modes/">Virtual
Memory</a>.</p>
<p>As always, these posts are meant to serve as a useful resource for folks who are
interested in learning more about RISC-V and low-level software in general. If I
can do a better job of reaching that goal, or you have any questions or
comments, please feel free to send me a message
<a href="https://twitter.com/hasheddan">@hasheddan</a> on Twitter!</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2023
     Daniel Mangum 
    Â·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://danielmangum.com/js/coder.min.27afce394fb6284f521b3fbc9f6a8326342333c3092267f3944d770489876fed.js" integrity="sha256-J6/OOU&#43;2KE9SGz&#43;8n2qDJjQjM8MJImfzlE13BImHb&#43;0="></script>
  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-116820283-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  

  

  

  

  

  

  
</body>

</html>
