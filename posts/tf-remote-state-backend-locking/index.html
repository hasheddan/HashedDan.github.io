<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  HashiCode Ep. 1: Terraform Remote State Backend Locking Â· Daniel Mangum
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Daniel Mangum">
<meta name="description" content="This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.
Disclaimer: this episode is referencing code from the Terraform codebase as of commit 43a7548. Becuase Terraform is a constanly evolving open source tool, the code is subject to change. However, the ideas expressed will largely remain the same.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://danielmangum.com/images/twitter-card.png"/>

<meta name="twitter:title" content="HashiCode Ep. 1: Terraform Remote State Backend Locking"/>
<meta name="twitter:description" content="This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.
Disclaimer: this episode is referencing code from the Terraform codebase as of commit 43a7548. Becuase Terraform is a constanly evolving open source tool, the code is subject to change. However, the ideas expressed will largely remain the same."/>

<meta property="og:title" content="HashiCode Ep. 1: Terraform Remote State Backend Locking" />
<meta property="og:description" content="This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.
Disclaimer: this episode is referencing code from the Terraform codebase as of commit 43a7548. Becuase Terraform is a constanly evolving open source tool, the code is subject to change. However, the ideas expressed will largely remain the same." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://danielmangum.com/posts/tf-remote-state-backend-locking/" /><meta property="og:image" content="https://danielmangum.com/images/twitter-card.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-17T00:31:39-05:00" />
<meta property="article:modified_time" content="2019-06-17T00:31:39-05:00" />




<link rel="canonical" href="https://danielmangum.com/posts/tf-remote-state-backend-locking/">


<link rel="preload" href="https://danielmangum.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://danielmangum.com/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css" integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://danielmangum.com/css/coder-dark.min.216e36d3eaf6f4cdfd67dc1200c49a8169e6478102977b3e9ac51a064c57054c.css" integrity="sha256-IW420&#43;r29M39Z9wSAMSagWnmR4ECl3s&#43;msUaBkxXBUw=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://danielmangum.com/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://danielmangum.com/images/apple-touch-icon.png">

<link rel="manifest" href="https://danielmangum.com/site.webmanifest">
<link rel="mask-icon" href="https://danielmangum.com/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.111.3">





  </head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://danielmangum.com/">
      Daniel Mangum
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/categories/risc-v-bytes/">[RISC-V Bytes]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/risc-v-tips/">[RISC-V Tips]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/posts/">[Blog]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/about/">[About]</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://danielmangum.com/posts/tf-remote-state-backend-locking/">
              HashiCode Ep. 1: Terraform Remote State Backend Locking
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2019-06-17T00:31:39-05:00">
                June 17, 2019
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              30-minute read
            </span>
          </div>
          
          
          
        </div>
      </header>

      <div class="post-content">
        
        <p><em>This is the first installment of HashiCode, a blog post series where I go through the source code of HashiCorp tools to learn more about what happens behind the scenes when you interact with tools as a user.</em></p>
<p><em>Disclaimer: this episode is referencing code from the Terraform codebase as of commit <a href="https://github.com/hashicorp/terraform/tree/43a754829ae7afcb26bccd275fb3ae9d3e0cda88">43a7548</a>. Becuase Terraform is a constanly evolving open source tool, the code is subject to change. However, the ideas expressed will largely remain the same.</em></p>
<p>One of the issues that teams using Terraform to provision infrastructure run into quickly is managing who is changing what and at what time are they doing it. Terraform introduces the concept of <a href="https://www.terraform.io/docs/state/remote.html">remote state</a>, which allows users to interact with the same existing infrastructure resources. While this is powerful, it also provides more opportunities for issues. One of the most common solutions is <strong>locking</strong>.</p>
<p>If you have ever interacted with a database, you may be familiar with the concept of locking. It solves the problem of data races when two different sessions are attempting to modify the same value at the same time. A common example is banking: imagine you have $100 in your bank account. If you deposited $20 and another user on your bank account deposited $50 at the same time, there is potential that one transaction overwrites the other. In short, if the second transaction begins before the first transaction ends, your bank balance will only be $150 instead of $170 when the second transaction ends. This is because when the second transaction started the bank account had $100 in it, and it increased that value by $50 and committed it.</p>
<p>Locking solves this by <em>locking</em> writes to the database when a transaction starts. So going back to the bank example, when the first transaction begins it would take out a lock on the account, and when the second transaction wanted to begin, it would be told to wait until the first finished. The first would finish, bringing the balance to $120, then release the lock. The second would then take out a lock, and since the first transaction has completed and been committed, would then increase the balance to $150, before releasing the lock. This is a simple example, and there are multiple locking strategies that can be implemented to address certain types of collisions, but I will leave you to research more about that on your own. One of my favorite summaries is <a href="http://www.agiledata.org/essays/concurrencyControl.html">here</a>, and if you are interested in how locking is actually implemented in common database management systems take a look <a href="https://www.geeksforgeeks.org/implementation-of-locking-in-dbms/">here</a>.</p>
<p>You may have already begun to see how this could come up in modifying remote state, and how a <code>.tfstate</code> file is much like a database. Just like collisions may occur when multiple parties are writing to a database, collisions may also occur when modifying infrastructure. For instance, if I want to add a target group to an application load balancer on AWS, and you want to delete that load balancer at the same time, what happens? Similarly, if I want to reference outputs from the state of another Terraform configuration, what happens if the state of that configuration is being changed while I try to read it? As previously mentioned, if we are sharing state remotely, we are interacting with the same source of truth.</p>
<p><a href="https://aws.amazon.com/s3/">S3</a> is a common place to store shared state files for Terraform. Terraform allows for the use of multiple types of backends, and S3 has been one of the most popular since it was implemented as a remote state wrapper by Gruntwork&rsquo;s <a href="https://github.com/gruntwork-io/terragrunt">Terragrunt</a> prior to officially being fully implemented within Terraform itself. It works with <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a> to allow for full backend functionality, which includes storage, versioning, encryption, and locking. As we look through the actual Terraform <a href="https://github.com/hashicorp/terraform">source code</a> to see how S3 is implemented as a backend, we can gain a greater understanding for what happens when we use it and how we can leverage it within an organization.</p>
<h2 id="a-background-on-backends">
  A Background on Backends
  <a class="heading-link" href="#a-background-on-backends">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>If you have ever used Terraform you are probably familair with the concept of <code>.tfstate</code> files. Whether you know exactly how they are constructed, or you just know that they are a remnant of running most Terraform operations, they are handling a big part of the functionality of Terraform. They keep track of what has already been provisioned, which allows Terraform to know what exists, how it can be updated / deleted, and how new resources can interact with existing. If you were to delete a <code>.tfstate</code> file, then run <code>terraform apply</code>, Terraform would recreate all the resources defined in your configuration, and you be no longer able to manage the existing resources that you previously deployed.</p>
<p>Backends come in two flavors in Terraform: <em>standard</em> and <em>enhanced</em>. The difference between the two is pretty straightforward. Most backends are standard, which means they basically just manage state. Enhanced backends do this as well, but also can execute remote operations so that you can initiate Terraform commands from your local machine, but then go about your day as the provisioning process is offloaded to an enhanced backend. You can read more about the difference between types of backends <a href="https://www.terraform.io/docs/backends/types/index.html">here</a>, but it is useful to think about backends by talking about the one that you are probably already familiar with: <strong>local</strong>.</p>
<p>Local itself is an enhanced backend because it both handles state and can execute operations. Backends are basically just engines, giving Terraform the compute and storage resources (and some light logic to interact with them) that it needs to work. Because we are primarily interested in the topic of remote state locking, we will focus in only on the the subset of functionality that is encompassed by a standard backend. So how does the local backend handle state? Well we already alluded to it earlier. It uses your local file system and creates <code>.tfstate</code> files. But it actually doesn&rsquo;t have to! While there are two types of backends, we actually <em>always are using an enhanced backend</em>. This is because to ever interact with a standard backend we must go through an enhanced one (namely <code>local</code>, more on this later).</p>
<blockquote>
<p>The local backend, which is of type <em>backend.Enhanced</em> is actually used to execute all of the backends of type <em>backend.Backend</em>.</p>
</blockquote>
<p>To truly understand this, we must look into the source code. HashiCorp tools are mostly written in Go (<a href="https://github.com/hashicorp/vagrant">Vagrant</a>, the oldest tool, is written in Ruby). A common design pattern in Go, and most programming languages for that matter, is to define an interface which describes the functionality of a broad type, and then have multiple implementations that adhere to the specifications. HashiCorp utilizes this pattern quite heavily, and it allows for the tools to be built using a &ldquo;plugin&rdquo; architecture, which has been a significant factor in their rapid adoption and growth (we will certainly be diving deeper into this plugin architecture in later episodes of HashiCode). Importantly, both the &ldquo;internal&rdquo; (or built-in) and extendable parts of Terraform are constructed in this manner, and backends, which would be considered internal in this case are no exception.</p>
<p>The general <code>Backend</code> interface is defined in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/backend.go">terraform/backend/backend.go</a>. Here is a snippet of it in which I have removed code comments for brevity:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Backend is the minimal interface that must be implemented to enable Terraform.
</span></span><span style="display:flex;"><span>type Backend interface {
</span></span><span style="display:flex;"><span>	ConfigSchema() *configschema.Block
</span></span><span style="display:flex;"><span>	PrepareConfig(cty.Value) (cty.Value, tfdiags.Diagnostics)
</span></span><span style="display:flex;"><span>	Configure(cty.Value) tfdiags.Diagnostics
</span></span><span style="display:flex;"><span>	StateMgr(workspace string) (statemgr.Full, error)
</span></span><span style="display:flex;"><span>	DeleteWorkspace(name string) error
</span></span><span style="display:flex;"><span>	Workspaces() ([]string, error)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As the comment on the exported <code>Backend</code> interface suggests, this is the &ldquo;minimal interface that must be implemented&rdquo;. If we go back and think about our two types of backends (standard and enhanced) and remember that the functionality of an enhanced backend is a <em>superset</em> of that of the standard backend, then we can reach the conclusion that a standard backend must implement these six methods, while an enhanced backend must implement these six plus some more. And the code reflects this! If we look just below the <code>Backend</code> interface, we see the <code>Enhanced</code> interface (comments preserved this time):</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Enhanced implements additional behavior on top of a normal backend.
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span>// Enhanced backends allow customizing the behavior of Terraform operations.
</span></span><span style="display:flex;"><span>// This allows Terraform to potentially run operations remotely, load
</span></span><span style="display:flex;"><span>// configurations from external sources, etc.
</span></span><span style="display:flex;"><span>type Enhanced interface {
</span></span><span style="display:flex;"><span>	Backend
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Operation performs a Terraform operation such as refresh, plan, apply.
</span></span><span style="display:flex;"><span>	// It is up to the implementation to determine what &#34;performing&#34; means.
</span></span><span style="display:flex;"><span>	// This DOES NOT BLOCK. The context returned as part of RunningOperation
</span></span><span style="display:flex;"><span>	// should be used to block for completion.
</span></span><span style="display:flex;"><span>	// If the state used in the operation can be locked, it is the
</span></span><span style="display:flex;"><span>	// responsibility of the Backend to lock the state for the duration of the
</span></span><span style="display:flex;"><span>	// running operation.
</span></span><span style="display:flex;"><span>	Operation(context.Context, *Operation) (*RunningOperation, error)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Here we see another powerful property of Go, the ability for one interface to <em>wrap</em> another. This concept is called <em>composition</em>. Most programming languages allow for composition, but users frequently confuse composition with inheritance. Go does not provide classes or inheritance, but instead achieves polymorphism through composition and struct embedding. In this way, eliminates the fundamental problem of a <a href="https://en.wikipedia.org/wiki/Fragile_base_class">fragile base class</a> in object oriented programming. Composition an interface esstentially is just saying &ldquo;I will do everything this interface does, plus some more&rdquo;. So here, <code>Enhanced</code> is saying that it will do everything that <code>Backend</code> does, but also implement the ability to execute <code>Operation()</code>. This is exactly what we stated earlier about standard and enhanced backends: enhanced backends can do everything standard ones do, but can also execute <em>remote operations</em>. Do not take the clarity of this code for granted. You will see many code bases that are not near as readable / understandable as this, which is both a nod to the Go language and also to Mitchell Hashimoto, one of the founders of HashiCorp and the writer of this very block of code (You can actually check out the commit message where this was added <a href="https://github.com/hashicorp/terraform/commit/8a070ddef0659652636fcf570988c33eee19ec6b">here</a>. The fact that it has not been touched for two years is a pretty solid indication of the effectiveness of the initial implementation).</p>
<p>So back to our original question: why do we have to go through an enhanced backend to interact with a standard one? Well if we consider that Terraform must always be able to execute operations and must always be able to handle state, and we also acknowledge that both of these things are always handled by a backend, then we reach the conclusion that we can never only be using a standard backend because we would be unable to execute any operations. If this still feels confusing, let&rsquo;s consider that there are only two types of enhanced backends: <code>local</code> and <code>remote</code> (i.e. Terraform Enterprise). Remote performs operations (i.e. <code>Operation()</code>) and manages state (i.e. <code>Backend</code>) in Terraform Enterprise. Local, on the other hand, performs operations locally, but can substitute either local or a remote-state <code>Backend</code> to manage state.</p>
<p>This is a good time to look at the structure of the <code>terraform/backend</code> directory.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>backend/
</span></span><span style="display:flex;"><span>    atlas/          # Legacy backend Atlas support
</span></span><span style="display:flex;"><span>    init/           # Provides initialization methods for each backend type to Terraform
</span></span><span style="display:flex;"><span>    local/          # Local backend that implements Enhanced
</span></span><span style="display:flex;"><span>    remote/         # Remote (TF Enterprise) backend that implements Enhanced
</span></span><span style="display:flex;"><span>    remote-state/   # Remote state backends that implement Backend
</span></span><span style="display:flex;"><span>    backend.go      # Backend and Enhanced interfaces
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>As you can see, the directory structure closely reflects the separation of functionality for each backend. If we look into <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/init/init.go">terraform/backend/init/init.go</a> we can see how each backend implementation is exposed to Terraform:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Init initializes the backends map with all our hardcoded backends.
</span></span><span style="display:flex;"><span>func Init(services *disco.Disco) {
</span></span><span style="display:flex;"><span>	backendsLock.Lock()
</span></span><span style="display:flex;"><span>	defer backendsLock.Unlock()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	backends = map[string]backend.InitFn{
</span></span><span style="display:flex;"><span>		// Enhanced backends.
</span></span><span style="display:flex;"><span>		&#34;local&#34;:  func() backend.Backend { return backendLocal.New() },
</span></span><span style="display:flex;"><span>		&#34;remote&#34;: func() backend.Backend { return backendRemote.New(services) },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// Remote State backends.
</span></span><span style="display:flex;"><span>		&#34;artifactory&#34;: func() backend.Backend { return backendArtifactory.New() },
</span></span><span style="display:flex;"><span>		&#34;atlas&#34;:       func() backend.Backend { return backendAtlas.New() },
</span></span><span style="display:flex;"><span>		&#34;azurerm&#34;:     func() backend.Backend { return backendAzure.New() },
</span></span><span style="display:flex;"><span>		&#34;consul&#34;:      func() backend.Backend { return backendConsul.New() },
</span></span><span style="display:flex;"><span>		&#34;etcd&#34;:        func() backend.Backend { return backendEtcdv2.New() },
</span></span><span style="display:flex;"><span>		&#34;etcdv3&#34;:      func() backend.Backend { return backendEtcdv3.New() },
</span></span><span style="display:flex;"><span>		&#34;gcs&#34;:         func() backend.Backend { return backendGCS.New() },
</span></span><span style="display:flex;"><span>		&#34;http&#34;:        func() backend.Backend { return backendHTTP.New() },
</span></span><span style="display:flex;"><span>		&#34;inmem&#34;:       func() backend.Backend { return backendInmem.New() },
</span></span><span style="display:flex;"><span>		&#34;manta&#34;:       func() backend.Backend { return backendManta.New() },
</span></span><span style="display:flex;"><span>		&#34;oss&#34;:         func() backend.Backend { return backendOSS.New() },
</span></span><span style="display:flex;"><span>		&#34;pg&#34;:          func() backend.Backend { return backendPg.New() },
</span></span><span style="display:flex;"><span>		&#34;s3&#34;:          func() backend.Backend { return backendS3.New() },
</span></span><span style="display:flex;"><span>		&#34;swift&#34;:       func() backend.Backend { return backendSwift.New() },
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// Deprecated backends.
</span></span><span style="display:flex;"><span>		&#34;azure&#34;: func() backend.Backend {
</span></span><span style="display:flex;"><span>			return deprecateBackend(
</span></span><span style="display:flex;"><span>				backendAzure.New(),
</span></span><span style="display:flex;"><span>				`Warning: &#34;azure&#34; name is deprecated, please use &#34;azurerm&#34;`,
</span></span><span style="display:flex;"><span>			)
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now let&rsquo;s venture into <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/local/backend.go">terraform/backend/local/backend.go</a>. Luckily for us, the comments are verbose and do a great job of explaining exactly what we are looking at:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Local is an implementation of EnhancedBackend that performs all operations
</span></span><span style="display:flex;"><span>// locally. This is the &#34;default&#34; backend and implements normal Terraform
</span></span><span style="display:flex;"><span>// behavior as it is well known.
</span></span><span style="display:flex;"><span>type Local struct {
</span></span><span style="display:flex;"><span>	// CLI and Colorize control the CLI output. If CLI is nil then no CLI
</span></span><span style="display:flex;"><span>	// output will be done. If CLIColor is nil then no coloring will be done.
</span></span><span style="display:flex;"><span>	CLI      cli.Ui
</span></span><span style="display:flex;"><span>	CLIColor *colorstring.Colorize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// ShowDiagnostics prints diagnostic messages to the UI.
</span></span><span style="display:flex;"><span>	ShowDiagnostics func(vals ...interface{})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// The State* paths are set from the backend config, and may be left blank
</span></span><span style="display:flex;"><span>	// to use the defaults. If the actual paths for the local backend state are
</span></span><span style="display:flex;"><span>	// needed, use the StatePaths method.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// StatePath is the local path where state is read from.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// StateOutPath is the local path where the state will be written.
</span></span><span style="display:flex;"><span>	// If this is empty, it will default to StatePath.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// StateBackupPath is the local path where a backup file will be written.
</span></span><span style="display:flex;"><span>	// Set this to &#34;-&#34; to disable state backup.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// StateWorkspaceDir is the path to the folder containing data for
</span></span><span style="display:flex;"><span>	// non-default workspaces. This defaults to DefaultWorkspaceDir if not set.
</span></span><span style="display:flex;"><span>	StatePath         string
</span></span><span style="display:flex;"><span>	StateOutPath      string
</span></span><span style="display:flex;"><span>	StateBackupPath   string
</span></span><span style="display:flex;"><span>	StateWorkspaceDir string
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// The OverrideState* paths are set based on per-operation CLI arguments
</span></span><span style="display:flex;"><span>	// and will override what&#39;d be built from the State* fields if non-empty.
</span></span><span style="display:flex;"><span>	// While the interpretation of the State* fields depends on the active
</span></span><span style="display:flex;"><span>	// workspace, the OverrideState* fields are always used literally.
</span></span><span style="display:flex;"><span>	OverrideStatePath       string
</span></span><span style="display:flex;"><span>	OverrideStateOutPath    string
</span></span><span style="display:flex;"><span>	OverrideStateBackupPath string
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// We only want to create a single instance of a local state, so store them
</span></span><span style="display:flex;"><span>	// here as they&#39;re loaded.
</span></span><span style="display:flex;"><span>	states map[string]statemgr.Full
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Terraform context. Many of these will be overridden or merged by
</span></span><span style="display:flex;"><span>	// Operation. See Operation for more details.
</span></span><span style="display:flex;"><span>	ContextOpts *terraform.ContextOpts
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// OpInput will ask for necessary input prior to performing any operations.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// OpValidation will perform validation prior to running an operation. The
</span></span><span style="display:flex;"><span>	// variable naming doesn&#39;t match the style of others since we have a func
</span></span><span style="display:flex;"><span>	// Validate.
</span></span><span style="display:flex;"><span>	OpInput      bool
</span></span><span style="display:flex;"><span>	OpValidation bool
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Backend, if non-nil, will use this backend for non-enhanced behavior.
</span></span><span style="display:flex;"><span>	// This allows local behavior with remote state storage. It is a way to
</span></span><span style="display:flex;"><span>	// &#34;upgrade&#34; a non-enhanced backend to an enhanced backend with typical
</span></span><span style="display:flex;"><span>	// behavior.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// If this is nil, local performs normal state loading and storage.
</span></span><span style="display:flex;"><span>	Backend backend.Backend
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// RunningInAutomation indicates that commands are being run by an
</span></span><span style="display:flex;"><span>	// automated system rather than directly at a command prompt.
</span></span><span style="display:flex;"><span>	//
</span></span><span style="display:flex;"><span>	// This is a hint not to produce messages that expect that a user can
</span></span><span style="display:flex;"><span>	// run a follow-up command, perhaps because Terraform is running in
</span></span><span style="display:flex;"><span>	// some sort of workflow automation tool that abstracts away the
</span></span><span style="display:flex;"><span>	// exact commands that are being run.
</span></span><span style="display:flex;"><span>	RunningInAutomation bool
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// opLock locks operations
</span></span><span style="display:flex;"><span>	opLock sync.Mutex
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>var _ backend.Backend = (*Local)(nil)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// New returns a new initialized local backend.
</span></span><span style="display:flex;"><span>func New() *Local {
</span></span><span style="display:flex;"><span>	return NewWithBackend(nil)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// NewWithBackend returns a new local backend initialized with a
</span></span><span style="display:flex;"><span>// dedicated backend for non-enhanced behavior.
</span></span><span style="display:flex;"><span>func NewWithBackend(backend backend.Backend) *Local {
</span></span><span style="display:flex;"><span>	return &amp;Local{
</span></span><span style="display:flex;"><span>		Backend: backend,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The first thing you may notice is the <code>Local</code> struct, which has comments that conveniently tell us that it implements EnhancedBackend (i.e. <code>backend.Enhanced</code>). As we have said many times, an enhanced backend (<code>backend.Enhanced</code>) must implement everything that a standard (<code>backend.Backend</code>) does, plus be able to perform operations. If you look farther down in this file, you will see the following methods implemented:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func (b *Local) ConfigSchema() *configschema.Block
</span></span><span style="display:flex;"><span>func (b *Local) PrepareConfig(obj cty.Value) (cty.Value, tfdiags.Diagnostics)
</span></span><span style="display:flex;"><span>func (b *Local) Configure(obj cty.Value) tfdiags.Diagnostics
</span></span><span style="display:flex;"><span>func (b *Local) Workspaces() ([]string, error)
</span></span><span style="display:flex;"><span>func (b *Local) DeleteWorkspace(name string) error
</span></span><span style="display:flex;"><span>func (b *Local) StateMgr(name string) (statemgr.Full, error)
</span></span></code></pre></div><p>We recognize these as implementations of the six required methods found in <code>backend.Backend</code>. So we can think of these as the standard backend methods that are used to handle state. You can also see in the <code>Local</code> struct that there is a field Backend of type <code>backend.Backend</code>. This reminds us a lot of how the <code>backend.Enhanced</code> interface (which <code>Local</code> is implementing here) wrapped <code>backend.Backend</code>! However, I said earlier that <code>local</code> may manage state itself, or substitute in one of the <code>remote-state</code> backends to do so. How does that work? Well let&rsquo;s look back up to <code>New()</code> and <code>NewWithBackend()</code> just after the <code>Local</code> struct. If you look closely, you can see that <code>New()</code> simply calls <code>NewWithBackend(nil)</code> which sets the <code>Backend</code> field of <code>Local</code> to <code>nil</code>. Then, if we look at each of the six methods defined to implement <code>backend.Backend</code>, we notice that they all start with the following code block:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    if b.Backend != nil {
</span></span><span style="display:flex;"><span>		return b.Backend.ConfigSchema() # This is the example from ConigSchema()
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>This basically says if we have substituted in another <code>backend.Backend</code> (i.e. <code>b.Backend != nil</code>) then turn over the implementation of this method to that backend. Otherwise, the method as defined in <code>Local</code> will execute. This is the behavior that you may be familiar with. If you look through these methods and their child methods, you will notice the functionality defined to write local <code>.tfstate</code> files and manage all state in your filesystem. However, the <code>Operation()</code> method, which is also defined farther down in this file, does not contain the same code block to check which backend is configured. This is because <code>Operation()</code> is part of <code>backend.Enhanced</code>, so the given <code>backend.Backend</code> is standard so is not able to execute operations.</p>
<blockquote>
<p>In short, <code>Local</code> must manage operations, but may or may not manage state.</p>
</blockquote>
<h2 id="the-s3-remote-state-backend">
  The S3 Remote State Backend
  <a class="heading-link" href="#the-s3-remote-state-backend">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>So let&rsquo;s take a look at one of the <code>backend.Backend</code> implementations that <code>Local</code> might push off handling state to. These are kept in <a href="https://github.com/hashicorp/terraform/tree/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/remote-state">terraform/backend/remote-state</a>. Upon navigating to the directory you will see a multitude of implementations ranging from Consul to Postgres. Each of the implementation directories contains at least the following three files:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>backend.go          # Creation of the given remote state backend (implements backend.Backend)
</span></span><span style="display:flex;"><span>backend_state.go    # Implementation of required backend.Backend methods
</span></span><span style="display:flex;"><span>client.go           # Implementation of methods used to interact with the remote state provider
</span></span></code></pre></div><p>Upon further examination of each of the remote state implementations, you will notice that their <code>backend.go</code> files all follow a similar pattern. Namely, they all embed <code>*schema.Backend</code>. We briefly mentioned earlier that another way that Go achieves polymorphism is through <em>struct embedding</em>, and that is exactly what is happening here. The <code>schema</code> package lives in the <code>helper/</code> directory, which is one that you may want to become familiar with if you plan on contributing to Terraform yourself. It contains many helpful libraries for abstracting away complexity that is common across a certain class of Terraform components and don&rsquo;t need to be reimplemented. In fact, that is exactly what it does here for our remote state backends. Let&rsquo;s take a look at <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/remote-state/s3/backend.go">terraform/backend/remote-state/s3/backend.go</a>. Skip over the <code>New()</code> function for a moment and check out the <code>Backend</code> struct:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>type Backend struct {
</span></span><span style="display:flex;"><span>	*schema.Backend
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// The fields below are set from configure
</span></span><span style="display:flex;"><span>	s3Client  *s3.S3
</span></span><span style="display:flex;"><span>	dynClient *dynamodb.DynamoDB
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	bucketName           string
</span></span><span style="display:flex;"><span>	keyName              string
</span></span><span style="display:flex;"><span>	serverSideEncryption bool
</span></span><span style="display:flex;"><span>	acl                  string
</span></span><span style="display:flex;"><span>	kmsKeyID             string
</span></span><span style="display:flex;"><span>	ddbTable             string
</span></span><span style="display:flex;"><span>	workspaceKeyPrefix   string
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>At the top, you&rsquo;ll see the aforementioned embedding of <code>*schema.Backend</code>, as well as a number of other fields specifically related to S3 as a remote state provider. Now if we look back at the <code>New()</code> function (exluded here for brevity), we will notice the creation of a <code>*schema.Backend</code>, which is a pointer to a struct, configured once again with S3 specific components. The schema is then embedded into a struct of type <code>s3.Backend</code> before being returned. You&rsquo;ll remember from where we looked at <code>Init()</code> above that this is exactly how an S3 remote state backend gets initialized.</p>
<p>So why does each of the remote state providers embed <code>*schema.Backend</code>? To understand, it is helpful to remember that the <code>backend.Backend</code> interface (or as we like to call it, the standard backend interface) requires the implementation of six methods. Unsurprisingly, all of the remote state backends implement a few of those methods in very similar ways. <code>ConigSchema()</code>, <code>PrepareConfig()</code>, and <code>Configure()</code> share much of the same steps for each, so instead of reimplementing them every time we add a new remote state provider, we instead choose for each remote state backend to adhere to a contract with <code>*schema.Backend</code> saying that they will provide the necessary information for <code>*schema.Backend</code> to execute those methods for them (notice that they do cheat on this somewhat by setting the <code>ConfigureFunc</code> for <code>*schema.Backend</code> to call if additional custom configuration is needed for the provider). If you look at the <code>Backend</code> implementation in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/helper/schema/backend.go">terraform/helper/schema/backend.go</a>, the comments reinforce what we have just discovered:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Backend represents a partial backend.Backend implementation and simplifies
</span></span><span style="display:flex;"><span>// the creation of configuration loading and validation.
</span></span><span style="display:flex;"><span>//
</span></span><span style="display:flex;"><span>// Unlike other schema structs such as Provider, this struct is meant to be
</span></span><span style="display:flex;"><span>// embedded within your actual implementation. It provides implementations
</span></span><span style="display:flex;"><span>// only for Input and Configure and gives you a method for accessing the
</span></span><span style="display:flex;"><span>// configuration in the form of a ResourceData that you&#39;re expected to call
</span></span><span style="display:flex;"><span>// from the other implementation funcs.
</span></span><span style="display:flex;"><span>type Backend struct {
</span></span><span style="display:flex;"><span>	// Schema is the schema for the configuration of this backend. If this
</span></span><span style="display:flex;"><span>	// Backend has no configuration this can be omitted.
</span></span><span style="display:flex;"><span>	Schema map[string]*Schema
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// ConfigureFunc is called to configure the backend. Use the
</span></span><span style="display:flex;"><span>	// FromContext* methods to extract information from the context.
</span></span><span style="display:flex;"><span>	// This can be nil, in which case nothing will be called but the
</span></span><span style="display:flex;"><span>	// config will still be stored.
</span></span><span style="display:flex;"><span>	ConfigureFunc func(context.Context) error
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	config *ResourceData
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now let&rsquo;s look at S3&rsquo;s <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/remote-state/s3/backend_state.go">backend_state.go</a> file. This is where the remaining three <code>backend.Backend</code> methods are implemented: <code>Workspaces()</code>, <code>DeleteWorkspace()</code>, and <code>StateMgr()</code>. You&rsquo;ll also notice an unexported function (Go fields and functions are always exported if capitalized, always unexported if lowercase, read more <a href="https://www.ardanlabs.com/blog/2014/03/exportedunexported-identifiers-in-go.html">here</a>) named <code>remoteClient()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// get a remote client configured for this state
</span></span><span style="display:flex;"><span>func (b *Backend) remoteClient(name string) (*RemoteClient, error) {
</span></span><span style="display:flex;"><span>	if name == &#34;&#34; {
</span></span><span style="display:flex;"><span>		return nil, errors.New(&#34;missing state name&#34;)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	client := &amp;RemoteClient{
</span></span><span style="display:flex;"><span>		s3Client:             b.s3Client,
</span></span><span style="display:flex;"><span>		dynClient:            b.dynClient,
</span></span><span style="display:flex;"><span>		bucketName:           b.bucketName,
</span></span><span style="display:flex;"><span>		path:                 b.path(name),
</span></span><span style="display:flex;"><span>		serverSideEncryption: b.serverSideEncryption,
</span></span><span style="display:flex;"><span>		acl:                  b.acl,
</span></span><span style="display:flex;"><span>		kmsKeyID:             b.kmsKeyID,
</span></span><span style="display:flex;"><span>		ddbTable:             b.ddbTable,
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	return client, nil
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>What you see here is all of those S3-specific config data being passed to a <code>RemoteClient</code> struct. Then if you look a little bit further down in the <code>StateMgr()</code> function, you&rsquo;ll notice that <code>remoteClient()</code> is the first thing that is called. Once again, this is a common pattern that you will see across the remote state backends: create a client and then use it to interact with the state provider. In the case of S3, we are passing in thing such as the AWS S3 and DynamoDB Go clients, the bucket name, the path for the <code>.tfstate</code> file, and various other values. All of these are used to write state files to an S3 bucket, as well as handle locking.</p>
<h2 id="so-what-about-this-locking-business">
  So what about this locking business?
  <a class="heading-link" href="#so-what-about-this-locking-business">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>We briefly defined what locking is at the beginning, but let&rsquo;s revisit now that we have a little more context. Locking solves the problem of simulatenous access to state. If I am updating the state, I don&rsquo;t want you updating it or reading it until my changes are complete and committed. As we dive even further into the S3 remote state backend, we will see one implementation of how locking can be applied to remote state in Terraform.</p>
<p>Going back to the <code>StateMgr()</code> function, let&rsquo;s examine what it does after creating a remote client:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-mysql" data-lang="mysql"><span style="display:flex;"><span>func (b *Backend) StateMgr(name string) (state.State, error) <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>	client, err := b.remoteClient(name)
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">return</span> nil, err
</span></span><span style="display:flex;"><span>	<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	stateMgr := &amp;remote.State<span style="color:#f00">{</span>Client: client<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>	// <span style="color:#fff;font-weight:bold">Check</span> <span style="color:#fff;font-weight:bold">to</span> see <span style="color:#fff;font-weight:bold">if</span> this state already <span style="color:#fff;font-weight:bold">exists</span>.
</span></span><span style="display:flex;"><span>	// <span style="color:#fff;font-weight:bold">If</span> we<span style="color:#0ff;font-weight:bold">&#39;re trying to force-unlock a state, we can&#39;</span>t take the <span style="color:#fff;font-weight:bold">lock</span> <span style="color:#fff;font-weight:bold">before</span>
</span></span><span style="display:flex;"><span>	// fetching the state. <span style="color:#fff;font-weight:bold">If</span> the state doesn<span style="color:#0ff;font-weight:bold">&#39;t exist, we have to assume this
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	// is a normal create operation, and take the lock at that point.
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	//
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	// If we need to force-unlock, but for some reason the state no longer
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	// exists, the user will have to use aws tools to manually fix the
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	// situation.
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	existing, err := b.Workspaces()
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	if err != nil {
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">		return nil, err
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	}
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	exists := false
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	for _, s := range existing {
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">		if s == name {
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">			exists = true
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">			break
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">		}
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	}
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">	// We need to create the object so it&#39;</span>s listed <span style="color:#fff;font-weight:bold">by</span> States.
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span> !<span style="color:#fff;font-weight:bold">exists</span> <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>		// take a <span style="color:#fff;font-weight:bold">lock</span> <span style="color:#fff;font-weight:bold">on</span> this state <span style="color:#fff;font-weight:bold">while</span> we <span style="color:#fff;font-weight:bold">write</span> it
</span></span><span style="display:flex;"><span>		lockInfo := state.NewLockInfo()
</span></span><span style="display:flex;"><span>		lockInfo.Operation = <span style="color:#0ff;font-weight:bold">&#34;init&#34;</span>
</span></span><span style="display:flex;"><span>		lockId, err := client.<span style="color:#fff;font-weight:bold">Lock</span>(lockInfo)
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> nil, fmt.Errorf(<span style="color:#0ff;font-weight:bold">&#34;failed to lock s3 state: %s&#34;</span>, err)
</span></span><span style="display:flex;"><span>		<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// Local helper function so we can <span style="color:#fff;font-weight:bold">call</span> it multiple places
</span></span><span style="display:flex;"><span>		lockUnlock := func(parent error) error <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">if</span> err := stateMgr.<span style="color:#fff;font-weight:bold">Unlock</span>(lockId); err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">return</span> fmt.Errorf(strings.TrimSpace(errStateUnlock), lockId, err)
</span></span><span style="display:flex;"><span>			<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> parent
</span></span><span style="display:flex;"><span>		<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// Grab the value
</span></span><span style="display:flex;"><span>		// This <span style="color:#fff;font-weight:bold">is</span> <span style="color:#fff;font-weight:bold">to</span> ensure that no one beat us <span style="color:#fff;font-weight:bold">to</span> writing a state <span style="color:#fff;font-weight:bold">between</span>
</span></span><span style="display:flex;"><span>		// the `<span style="color:#fff;font-weight:bold">exists</span>` <span style="color:#fff;font-weight:bold">check</span> <span style="color:#fff;font-weight:bold">and</span> taking the <span style="color:#fff;font-weight:bold">lock</span>.
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := stateMgr.RefreshState(); err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>			err = lockUnlock(err)
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> nil, err
</span></span><span style="display:flex;"><span>		<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// <span style="color:#fff;font-weight:bold">If</span> we have no state, we have <span style="color:#fff;font-weight:bold">to</span> <span style="color:#fff;font-weight:bold">create</span> an empty state
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> v := stateMgr.State(); v == nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">if</span> err := stateMgr.WriteState(states.NewState()); err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>				err = lockUnlock(err)
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">return</span> nil, err
</span></span><span style="display:flex;"><span>			<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">if</span> err := stateMgr.PersistState(); err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>				err = lockUnlock(err)
</span></span><span style="display:flex;"><span>				<span style="color:#fff;font-weight:bold">return</span> nil, err
</span></span><span style="display:flex;"><span>			<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>		<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		// <span style="color:#fff;font-weight:bold">Unlock</span>, the state should now be initialized
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">if</span> err := lockUnlock(nil); err != nil <span style="color:#f00">{</span>
</span></span><span style="display:flex;"><span>			<span style="color:#fff;font-weight:bold">return</span> nil, err
</span></span><span style="display:flex;"><span>		<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#f00">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">return</span> stateMgr, nil
</span></span><span style="display:flex;"><span><span style="color:#f00">}</span>
</span></span></code></pre></div><p>The first thing that jumps out is that we are wrapping the <code>client</code> in a struct of type <code>remote.State</code>. If we jump over to <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/state/remote/state.go">terraform/state/remote/state.go</a> we can take a look at exactly what <code>remote.State</code> encompasses and implements:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#007f7f">// State implements the State interfaces in the state package to handle
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// reading and writing the remote state. This State on its own does no
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// local caching so every persist will go to the remote storage and local
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// writes will go to memory.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">type</span> State <span style="color:#fff;font-weight:bold">struct</span> {
</span></span><span style="display:flex;"><span>	mu sync.Mutex
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	Client Client
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lineage          <span style="color:#fff;font-weight:bold">string</span>
</span></span><span style="display:flex;"><span>	serial           <span style="color:#fff;font-weight:bold">uint64</span>
</span></span><span style="display:flex;"><span>	state, readState *states.State
</span></span><span style="display:flex;"><span>	disableLocks     <span style="color:#fff;font-weight:bold">bool</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Methods implemented by <code>remote.State</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func (s *State) State() *states.State
</span></span><span style="display:flex;"><span>func (s *State) StateForMigration() *statefile.File
</span></span><span style="display:flex;"><span>func (s *State) WriteState(state *states.State) error
</span></span><span style="display:flex;"><span>func (s *State) WriteStateForMigration(f *statefile.File, force bool) error
</span></span><span style="display:flex;"><span>func (s *State) RefreshState() error
</span></span><span style="display:flex;"><span>func (s *State) refreshState() error
</span></span><span style="display:flex;"><span>func (s *State) PersistState() error
</span></span><span style="display:flex;"><span>func (s *State) Lock(info *state.LockInfo) (string, error)
</span></span><span style="display:flex;"><span>func (s *State) Unlock(id string) error
</span></span><span style="display:flex;"><span>func (s *State) DisableLocks()
</span></span><span style="display:flex;"><span>func (s *State) StateSnapshotMeta() statemgr.SnapshotMeta
</span></span></code></pre></div><p>Now we are really getting somewhere! These look like methods that might be called by commands with which we are familiar. We can think about what is actually happening when we <code>plan</code>, <code>apply</code>, or <code>destroy</code>. Here we are able to write state, referesh state, lock, unlock, and much more. These methods are all defined as interfaces in the <a href="https://github.com/hashicorp/terraform/tree/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/states/statemgr">terraform/states/statemgr</a> package, which I would encourage you to look through, along with the places they are actually called in like <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/command/meta_backend.go">terraform/command/meta_backend.go</a>. You can also wait until the last section of the episode, where I will quickly tie everything together.</p>
<p>Before we move on to the S3 client, check out the Client interface in the same directory: <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/state/remote/remote.go">terraform/state/remote/remote.go</a>. Here we define the methods we need to implement for our S3 client to be a compatible remote state backend:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Client is the interface that must be implemented for a remote state
</span></span><span style="display:flex;"><span>// driver. It supports dumb put/get/delete, and the higher level structs
</span></span><span style="display:flex;"><span>// handle persisting the state properly here.
</span></span><span style="display:flex;"><span>type Client interface {
</span></span><span style="display:flex;"><span>	Get() (*Payload, error)
</span></span><span style="display:flex;"><span>	Put([]byte) error
</span></span><span style="display:flex;"><span>	Delete() error
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// ClientLocker is an optional interface that allows a remote state
</span></span><span style="display:flex;"><span>// backend to enable state lock/unlock.
</span></span><span style="display:flex;"><span>type ClientLocker interface {
</span></span><span style="display:flex;"><span>	Client
</span></span><span style="display:flex;"><span>	state.Locker
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since we are using a remote state backend that does in fact implement locking, we will be using the <code>ClientLocker</code> interface, which requires everything that <code>Client</code> does plus everything that <code>state.Locker</code> does (hint: <code>state.Locker</code> is actually just an alias for <code>statemgr.Locker</code>, which only required the <code>Lock</code> and <code>Unlock</code> methods). If we look at our S3 client in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/backend/remote-state/s3/client.go">terraform/backend/remote-state/s3/client.go</a>, we see that it does in fact implement <code>Get()</code>, <code>Put()</code>, <code>Delete()</code>, <code>Lock()</code>, and <code>Unlock()</code>. These methods are called thoughout the methods implemented in <code>remote.State</code>, but since we are focused on <code>Lock()</code> and <code>Unlock()</code>, which are used before and after each operation respectively, we can just look back at our <code>StateMgr()</code> function for an example.</p>
<p>Essentially what this function is doing is taking a lock, initializing the state in S3 (i.e. writing an empty <code>.tfstate</code> file in the specified path), then unlocking. These actions are well defined because of strong naming conventions and verbose comments, but we have yet to look into what literally happens when we take a lock. Some of it happens in the <code>StateMgr()</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>        // take a lock on this state while we write it
</span></span><span style="display:flex;"><span>		lockInfo := state.NewLockInfo()
</span></span><span style="display:flex;"><span>		lockInfo.Operation = &#34;init&#34;
</span></span><span style="display:flex;"><span>		lockId, err := client.Lock(lockInfo)
</span></span><span style="display:flex;"><span>		if err != nil {
</span></span><span style="display:flex;"><span>			return nil, fmt.Errorf(&#34;failed to lock s3 state: %s&#34;, err)
</span></span><span style="display:flex;"><span>		}
</span></span></code></pre></div><p>We use some helpful utilies to generate our <code>lockInfo</code>, but then we hand it off to the S3 client. In the client, <code>Lock()</code> looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func (c *RemoteClient) Lock(info *state.LockInfo) (string, error) {
</span></span><span style="display:flex;"><span>	if c.ddbTable == &#34;&#34; {
</span></span><span style="display:flex;"><span>		return &#34;&#34;, nil
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	info.Path = c.lockPath()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if info.ID == &#34;&#34; {
</span></span><span style="display:flex;"><span>		lockID, err := uuid.GenerateUUID()
</span></span><span style="display:flex;"><span>		if err != nil {
</span></span><span style="display:flex;"><span>			return &#34;&#34;, err
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		info.ID = lockID
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	putParams := &amp;dynamodb.PutItemInput{
</span></span><span style="display:flex;"><span>		Item: map[string]*dynamodb.AttributeValue{
</span></span><span style="display:flex;"><span>			&#34;LockID&#34;: {S: aws.String(c.lockPath())},
</span></span><span style="display:flex;"><span>			&#34;Info&#34;:   {S: aws.String(string(info.Marshal()))},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		TableName:           aws.String(c.ddbTable),
</span></span><span style="display:flex;"><span>		ConditionExpression: aws.String(&#34;attribute_not_exists(LockID)&#34;),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	_, err := c.dynClient.PutItem(putParams)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		lockInfo, infoErr := c.getLockInfo()
</span></span><span style="display:flex;"><span>		if infoErr != nil {
</span></span><span style="display:flex;"><span>			err = multierror.Append(err, infoErr)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		lockErr := &amp;state.LockError{
</span></span><span style="display:flex;"><span>			Err:  err,
</span></span><span style="display:flex;"><span>			Info: lockInfo,
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		return &#34;&#34;, lockErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	return info.ID, nil
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We breezed by DynamoDB earlier, but if you are not familiar, it is a NoSQL document database that is fully managed by AWS. If you have ever used <a href="https://www.mongodb.com/">MongoDB</a>, it is very similar. What we want to do with a lock is tell everyone else that they can&rsquo;t access the state right now, while also checking that no one else is already accessing it. Going sequentially through the function implementation:</p>
<ol>
<li>We check to make sure a DynamoDB table name was defined on backend configuration</li>
<li>We check if the lock ID that is passed in is empty, and we generate a UUID for it if it is</li>
<li>We write the lock info to the Dynamo table</li>
<li>If there is already a lock at the same state path, we fail and return error</li>
<li>Otherwise, we return the <code>info.ID</code>, which is now part of the <code>Info</code> document at our state path in DynamoDB</li>
</ol>
<p>Then, back to <code>StateMgr()</code>, after initializing our state in S3 (feel free to look <code>WriteState()</code> and <code>PersistState()</code> functions for a deeper understanding), all of our changes in regards to <code>.tfstate</code> are complete and we can <code>Unlock()</code> by means of the <code>lockUnlock()</code> helper function. <code>Unlock()</code> is implemented in the S3 client as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func (c *RemoteClient) Unlock(id string) error {
</span></span><span style="display:flex;"><span>	if c.ddbTable == &#34;&#34; {
</span></span><span style="display:flex;"><span>		return nil
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	lockErr := &amp;state.LockError{}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// TODO: store the path and lock ID in separate fields, and have proper
</span></span><span style="display:flex;"><span>	// projection expression only delete the lock if both match, rather than
</span></span><span style="display:flex;"><span>	// checking the ID from the info field first.
</span></span><span style="display:flex;"><span>	lockInfo, err := c.getLockInfo()
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		lockErr.Err = fmt.Errorf(&#34;failed to retrieve lock info: %s&#34;, err)
</span></span><span style="display:flex;"><span>		return lockErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	lockErr.Info = lockInfo
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if lockInfo.ID != id {
</span></span><span style="display:flex;"><span>		lockErr.Err = fmt.Errorf(&#34;lock id %q does not match existing lock&#34;, id)
</span></span><span style="display:flex;"><span>		return lockErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	params := &amp;dynamodb.DeleteItemInput{
</span></span><span style="display:flex;"><span>		Key: map[string]*dynamodb.AttributeValue{
</span></span><span style="display:flex;"><span>			&#34;LockID&#34;: {S: aws.String(c.lockPath())},
</span></span><span style="display:flex;"><span>		},
</span></span><span style="display:flex;"><span>		TableName: aws.String(c.ddbTable),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	_, err = c.dynClient.DeleteItem(params)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		lockErr.Err = err
</span></span><span style="display:flex;"><span>		return lockErr
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	return nil
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Once again going sequentially:</p>
<ol>
<li>We check to make sure a DynamoDB table name was defined on backend configuration</li>
<li>Get the current lock info at the our state path in DynamoDB, return if unable or does not exist</li>
<li>Make sure the lock id retrieved matches the one that we put there when we used <code>Lock()</code>, return error if not</li>
<li>Delete our lock from DynamoDB, return nil error (lock deleted, everything okay)</li>
</ol>
<p>This is pretty simple, but very powerful. These two simple locking and unlocking functions allow us to make sure that no one else in our organization can access state as it is being modified, and we likewise cannot get a lock on the state if someone else has one.</p>
<h2 id="command-line-to-code">
  Command Line to Code
  <a class="heading-link" href="#command-line-to-code">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Wow we have jumped around a lot! It is okay if it is overwhelming. To bring it all together, let&rsquo;s start as a user, and go all the way to the the depths of the code that we reached. So where to begin?</p>
<p>Locking doesn&rsquo;t only take place when we initialize state. When it is enabled, it is used every time state is modified or accessed in any way. The nice thing about the way Terraform is architected is that if we want to add a new command to the CLI, we don&rsquo;t have to worry about locking. We know that a remote state backend that claims to have locking enabled must be implementing it (although unless you look at the source code you are trusting that it implements it correctly). Let&rsquo;s look at a simple example: reading the current state for a given configuration. The Terraform entrypoint is <code>terraform/main.go</code>, which initializes all of the available commands in <code>terraform/command.go</code>. For the actual implementation of the various commands, you must look into the <code>terraform/commands</code> directory. The command we need to read the current state is: <code>terraform state list</code>. The implementation lives in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/command/state_list.go">terraform/command/state_list.go</a>. The primary functionality is in <code>Run()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>func (c *StateListCommand) Run(args []string) int {
</span></span><span style="display:flex;"><span>	args, err := c.Meta.process(args, true)
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	var statePath string
</span></span><span style="display:flex;"><span>	cmdFlags := c.Meta.defaultFlagSet(&#34;state list&#34;)
</span></span><span style="display:flex;"><span>	cmdFlags.StringVar(&amp;statePath, &#34;state&#34;, &#34;&#34;, &#34;path&#34;)
</span></span><span style="display:flex;"><span>	lookupId := cmdFlags.String(&#34;id&#34;, &#34;&#34;, &#34;Restrict output to paths with a resource having the specified ID.&#34;)
</span></span><span style="display:flex;"><span>	if err := cmdFlags.Parse(args); err != nil {
</span></span><span style="display:flex;"><span>		return cli.RunResultHelp
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	args = cmdFlags.Args()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if statePath != &#34;&#34; {
</span></span><span style="display:flex;"><span>		c.Meta.statePath = statePath
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Load the backend
</span></span><span style="display:flex;"><span>	b, backendDiags := c.Backend(nil)
</span></span><span style="display:flex;"><span>	if backendDiags.HasErrors() {
</span></span><span style="display:flex;"><span>		c.showDiagnostics(backendDiags)
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Get the state
</span></span><span style="display:flex;"><span>	env := c.Workspace()
</span></span><span style="display:flex;"><span>	stateMgr, err := b.StateMgr(env)
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(errStateLoadingState, err))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	if err := stateMgr.RefreshState(); err != nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(&#34;Failed to load state: %s&#34;, err))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	state := stateMgr.State()
</span></span><span style="display:flex;"><span>	if state == nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(errStateNotFound))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	var addrs []addrs.AbsResourceInstance
</span></span><span style="display:flex;"><span>	var diags tfdiags.Diagnostics
</span></span><span style="display:flex;"><span>	if len(args) == 0 {
</span></span><span style="display:flex;"><span>		addrs, diags = c.lookupAllResourceInstanceAddrs(state)
</span></span><span style="display:flex;"><span>	} else {
</span></span><span style="display:flex;"><span>		addrs, diags = c.lookupResourceInstanceAddrs(state, args...)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	if diags.HasErrors() {
</span></span><span style="display:flex;"><span>		c.showDiagnostics(diags)
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	for _, addr := range addrs {
</span></span><span style="display:flex;"><span>		if is := state.ResourceInstance(addr); is != nil {
</span></span><span style="display:flex;"><span>			if *lookupId == &#34;&#34; || *lookupId == states.LegacyInstanceObjectID(is.Current) {
</span></span><span style="display:flex;"><span>				c.Ui.Output(addr.String())
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	c.showDiagnostics(diags)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	return 0
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It is fairly large, so let&rsquo;s narrow it down to the part we really care about, which is sandwiched in the middle:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>    // Load the backend
</span></span><span style="display:flex;"><span>	b, backendDiags := c.Backend(nil)
</span></span><span style="display:flex;"><span>	if backendDiags.HasErrors() {
</span></span><span style="display:flex;"><span>		c.showDiagnostics(backendDiags)
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	// Get the state
</span></span><span style="display:flex;"><span>	env := c.Workspace()
</span></span><span style="display:flex;"><span>	stateMgr, err := b.StateMgr(env)
</span></span><span style="display:flex;"><span>	if err != nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(errStateLoadingState, err))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	if err := stateMgr.RefreshState(); err != nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(&#34;Failed to load state: %s&#34;, err))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	state := stateMgr.State()
</span></span><span style="display:flex;"><span>	if state == nil {
</span></span><span style="display:flex;"><span>		c.Ui.Error(fmt.Sprintf(errStateNotFound))
</span></span><span style="display:flex;"><span>		return 1
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>Some of these calls should look familiar. The first thing we want to do is get the backend that has been configured for this session. <code>c.Backend(nil)</code> is calling the <code>Backend()</code> function in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/command/meta_backend.go">terraform/command/meta_backend.go</a>. This is where all of the setup for initializing the backend happens. I won&rsquo;t go through it here, but if you take a look you will see it checking if there is a remote state backend set, and if so, it is taking a local backend (enhanced) and injecting in the remote state backend (standard), just like we discussed early on in this post. Then, once we have setup the backend, we call that <code>StateMgr()</code> function that we spent so much time in and just examined for how it handles locking. This is the power of this type of construction. The <code>state list</code> command does not know or care which remote state backend is behind the scenes. It may use locking or it may not, but all the command cares about is that it satisfies its contract as specified by the <code>backend.Backend</code> (standard backend) interface.</p>
<p>Likewise, the <code>RefreshState()</code> and <code>State()</code> functions that we saw implemented in <a href="https://github.com/hashicorp/terraform/blob/43a754829ae7afcb26bccd275fb3ae9d3e0cda88/state/remote/state.go">remote.State</a> are obscured to the command, just like the <code>Get()</code>, <code>Put()</code>, <code>Lock</code>, and <code>Unlock</code> functions that are implemented in the <code>s3.Client</code> and called in <code>RefreshState()</code> and <code>State()</code> are obscured to <code>remote.State</code>. This separation of responsibilities lends itself to projects that can scale quickly, be extended by the community, and worked on in a distributed manner. It is no surprise that you see those very traits across the HashiCorp company.</p>
<h2 id="final-thoughts">
  Final Thoughts
  <a class="heading-link" href="#final-thoughts">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>I find the most effective way to learn a new code base is to interact with the binary as a user, think of a question you have about how it works, then trace the command you issued to the question you had. We started out this episode wanting to learn how the S3 remote state backend did locking, but we walked away understanding more about how HashiCorp architects its tools, what polymorphism looks like in Go, and a new confidence in contributing to open source projects that seem large and daunting.</p>
<p>I love open source because it is about people. Good projects survive because of empathy, not because of engineering. This is the first episode of HashiCode, and I hope that it is another step towards caring for people in the community.</p>
<p>As always, please feel free to reach out with question or comments on Twitter by tagging me or directly messaging me at <a href="https://twitter.com/hasheddan">@hasheddan</a>!</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2023
     Daniel Mangum 
    Â·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://danielmangum.com/js/coder.min.27afce394fb6284f521b3fbc9f6a8326342333c3092267f3944d770489876fed.js" integrity="sha256-J6/OOU&#43;2KE9SGz&#43;8n2qDJjQjM8MJImfzlE13BImHb&#43;0="></script>
  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-116820283-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  

  

  

  

  

  

  
</body>

</html>
