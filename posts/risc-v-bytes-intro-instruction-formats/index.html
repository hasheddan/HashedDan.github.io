<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
  RISC-V Bytes: Introduction to Instruction Formats Â· Daniel Mangum
</title>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Daniel Mangum">
<meta name="description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
So far in this series, we have been looking at the assembly generated when compiling relatively simple programs. At this point, we have seen instructions that perform a wide variety of operations. Let&rsquo;s take another look at our minimal example from the Passing on the Stack post:">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="RISC-V Bytes: Introduction to Instruction Formats"/>
<meta name="twitter:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
So far in this series, we have been looking at the assembly generated when compiling relatively simple programs. At this point, we have seen instructions that perform a wide variety of operations. Let&rsquo;s take another look at our minimal example from the Passing on the Stack post:"/>

<meta property="og:title" content="RISC-V Bytes: Introduction to Instruction Formats" />
<meta property="og:description" content="This is part of a series on the blog where we explore RISC-V by breaking down real programs and explaining how they work. You can view all posts in this series on the RISC-V Bytes page.
So far in this series, we have been looking at the assembly generated when compiling relatively simple programs. At this point, we have seen instructions that perform a wide variety of operations. Let&rsquo;s take another look at our minimal example from the Passing on the Stack post:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-12T00:10:34-06:00" />
<meta property="article:modified_time" content="2021-07-12T00:10:34-06:00" />




<link rel="canonical" href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats/">


<link rel="preload" href="https://danielmangum.com/fonts/forkawesome-webfont.woff2?v=1.2.0" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="https://danielmangum.com/css/coder.min.36f76aaf39a14ecf5c3a3c6250dcaf06c238b3d8365d17d646f95cb1874e852b.css" integrity="sha256-NvdqrzmhTs9cOjxiUNyvBsI4s9g2XRfWRvlcsYdOhSs=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="https://danielmangum.com/css/coder-dark.min.216e36d3eaf6f4cdfd67dc1200c49a8169e6478102977b3e9ac51a064c57054c.css" integrity="sha256-IW420&#43;r29M39Z9wSAMSagWnmR4ECl3s&#43;msUaBkxXBUw=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="https://danielmangum.com/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="https://danielmangum.com/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="https://danielmangum.com/images/apple-touch-icon.png">

<link rel="manifest" href="https://danielmangum.com/site.webmanifest">
<link rel="mask-icon" href="https://danielmangum.com/images/safari-pinned-tab.svg" color="#5bbad5">




<meta name="generator" content="Hugo 0.109.0">





  </head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://danielmangum.com/">
      Daniel Mangum
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/categories/risc-v-bytes/">[RISC-V Bytes]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/risc-v-tips/">[RISC-V Tips]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/posts/">[Blog]</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link" href="https://danielmangum.com/about/">[About]</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats/">
              RISC-V Bytes: Introduction to Instruction Formats
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa fa-calendar" aria-hidden="true"></i>
              <time datetime="2021-07-12T00:10:34-06:00">
                July 12, 2021
              </time>
            </span>
            <span class="reading-time">
              <i class="fa fa-clock-o" aria-hidden="true"></i>
              24-minute read
            </span>
          </div>
          
          <div class="categories">
  <i class="fa fa-folder" aria-hidden="true"></i>
    <a href="https://danielmangum.com/categories/risc-v-bytes/">RISC-V Bytes</a></div>

          
        </div>
      </header>

      <div class="post-content">
        
        <blockquote>
<p>This is part of a series on the blog where we explore
<a href="https://riscv.org/">RISC-V</a> by breaking down real programs and explaining how
they work. You can view all posts in this series on the <a href="https://danielmangum.com/categories/risc-v-bytes">RISC-V Bytes
page</a>.</p>
</blockquote>
<p>So far in this series, we have been looking at the assembly generated when
compiling relatively simple programs. At this point, we have seen instructions
that perform a wide variety of operations. Let&rsquo;s take another look at our
minimal example from the <a href="https://danielmangum.com/posts/risc-v-bytes-passing-on-the-stack/">Passing on the Stack
post</a>:</p>
<p><code>minimal.c</code></p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold">#include</span> <span style="color:#0f0;font-weight:bold">&lt;stdio.h&gt;</span><span style="color:#0f0;font-weight:bold">
</span></span></span><span style="display:flex;"><span><span style="color:#0f0;font-weight:bold"></span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> sum(<span style="color:#fff;font-weight:bold">int</span> one, <span style="color:#fff;font-weight:bold">int</span> two) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> one + two;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> main() {
</span></span><span style="display:flex;"><span>    printf(<span style="color:#0ff;font-weight:bold">&#34;The sum is: %d</span><span style="color:#0ff;font-weight:bold">\n</span><span style="color:#0ff;font-weight:bold">&#34;</span>, sum(<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>riscv64-unknown-elf-gcc -O3 -fno-inline -march=rv64g minimal.c</code></p>
<blockquote>
<p>Hold up a minute, what is that <code>-march=rv64g</code> doing in there? We didn&rsquo;t
compile with that flag in the last post, but we are providing it here to
disable instruction compression. The default <code>march</code> for our toolchain is
<code>rv64gc</code> (or more specifically <code>rv64imafdc</code>), but we are removing the <code>C</code>
extension, which indicates that a machine supports instruction compression. In
a future post we will explore how compression improves code size and why it
makes our generated assembly look different. You may already notice some
changes in the output below!</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) disass main
</span></span><span style="display:flex;"><span>Dump of assembler code for function main:
</span></span><span style="display:flex;"><span>   0x00000000000100b0 &lt;+0&gt;:         addi        sp,sp,-16
</span></span><span style="display:flex;"><span>   0x00000000000100b4 &lt;+4&gt;:         li          a1,2
</span></span><span style="display:flex;"><span>   0x00000000000100b8 &lt;+8&gt;:         li          a0,1
</span></span><span style="display:flex;"><span>   0x00000000000100bc &lt;+12&gt;:        sd          ra,8(sp)
</span></span><span style="display:flex;"><span>   0x00000000000100c0 &lt;+16&gt;:        jal         ra,0x101b8 &lt;sum&gt;
</span></span><span style="display:flex;"><span>   0x00000000000100c4 &lt;+20&gt;:        mv          a1,a0
</span></span><span style="display:flex;"><span>   0x00000000000100c8 &lt;+24&gt;:        lui         a0,0x21
</span></span><span style="display:flex;"><span>   0x00000000000100cc &lt;+28&gt;:        addi        a0,a0,-192 # 0x20f40
</span></span><span style="display:flex;"><span>   0x00000000000100d0 &lt;+32&gt;:        jal         ra,0x10418 &lt;printf&gt;
</span></span><span style="display:flex;"><span>   0x00000000000100d4 &lt;+36&gt;:        ld          ra,8(sp)
</span></span><span style="display:flex;"><span>   0x00000000000100d8 &lt;+40&gt;:        li          a0,0
</span></span><span style="display:flex;"><span>   0x00000000000100dc &lt;+44&gt;:        addi        sp,sp,16
</span></span><span style="display:flex;"><span>   0x00000000000100e0 &lt;+48&gt;:        ret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>(gdb) disass sum
</span></span><span style="display:flex;"><span>Dump of assembler code for function sum:
</span></span><span style="display:flex;"><span>   0x00000000000101b8 &lt;+0&gt;:         addw        a0,a0,a1
</span></span><span style="display:flex;"><span>   0x00000000000101bc &lt;+4&gt;:         ret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span></code></pre></div><p><a href="https://godbolt.org/z/najsrcG74">View on Compiler Explorer</a></p>
<p>In just this small example, we see multiple different types of instructions, and
their operands do not all look the same. Let&rsquo;s take a look at a few of them:</p>
<ul>
<li><code>addi</code>: we are using this in three different places in <code>&lt;main&gt;</code> to add or
subtract a value from one register and store it in another.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;+0&gt;:      addi        sp,sp,-16         # increase size of the stack frame by subtracting 16 bytes from stack pointer
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>&lt;+28&gt;:     addi        a0,a0,-192        # add -192 (base 10) to the value currently in a0
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>&lt;+44&gt;:     addi        sp,sp,16          # move stack pointer back to its location when we began the procedure
</span></span></code></pre></div><ul>
<li><code>sd</code>: we are using this in <code>&lt;main&gt;</code> to store the
<a href="https://danielmangum.com/posts/risc-v-bytes-caller-callee-registers/">caller-saved</a>
return address (<code>ra</code>) to a memory location on the stack.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;+12&gt;:    sd      ra,8(sp)
</span></span></code></pre></div><ul>
<li><code>lui</code>: we are using this in <code>&lt;main&gt;</code> to do . . . something?</li>
</ul>
<blockquote>
<p>Don&rsquo;t worry, we are going to define &ldquo;something&rdquo; in a bit.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;+14&gt;:    lui     a0,0x21
</span></span></code></pre></div><ul>
<li><code>addw</code>: we are using this in <code>&lt;sum&gt;</code> to add the values in <code>a0</code> and <code>a1</code> and
store the result in <code>a0</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>&lt;+0&gt;:     addw    a0,a0,a1
</span></span></code></pre></div><p>There are more instructions than these four, but you&rsquo;ll notice something
interesting about this group: all of them take operands in a slightly different
manner. For instance, <code>addi</code> takes three operands, two of which are registers,
and one of which is a decimal value (base 10). <code>sd</code> takes two operands, one
register and one register with an <em>offset</em> (more on this in a bit). <code>lui</code> takes
two operands as well, the first being a register, and the second being a
hexadecimal value (base 16). Lastly, <code>addw</code> takes three operands, all of them
registers.</p>
<p>Why is this interesting? Well, though we often think about assembly as &ldquo;talking
directly to the hardware&rdquo;, it is important to remember that the processor
understands binary machine code. Therefore, each of these instructions, as well
as all of their operands, must be encoded in binary in order to be interpreted.
When different operations require varying numbers and types of operands, we must
tell the processor how to interpret the operands that we provide.</p>
<h2 id="risc-v-instruction-format-overview">
  RISC-V Instruction Format Overview
  <a class="heading-link" href="#risc-v-instruction-format-overview">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>The binary encoding of an operation is referred to as its instruction format.
RISC-V has six core instruction formats:</p>
<p><img src="../../static/risc_v_inst_intro_1.png" alt="instructions"></p>
<blockquote>
<p>The <code>B</code> format is variation of <code>S</code> and is sometimes referred to as <code>SB</code>.
Similarly, the <code>J</code> format is a variation of <code>U</code> and is sometimes referred to
as <code>UJ</code>.</p>
</blockquote>
<p>There are a few immediate observations we can make about these core formats:</p>
<ul>
<li>They are all 32 bits (<code>[31:0]</code>) wide.</li>
<li>They all reserve the first 7 bits (<code>[6:0]</code>) for the <code>opcode</code>.</li>
<li>If two formats support the same operand, that operand is always in the same
location in the instruction (e.g. <code>R</code>, <code>I</code>, <code>S</code>, and <code>B</code> formats all have an
<code>rs1</code> operand and it is always encoded in bits <code>[19:15]</code>).</li>
<li>Each involves at least one register operand (<code>rd</code> / <code>rs1</code>/ <code>rs2</code>).</li>
<li>All register operands are the same number of bits (5).</li>
</ul>
<p>Each format is designed to accommodate certain types of instructions. While two
types of instructions that fall under the same format may seem unrelated, we
will see later on that they frequently will be implemented using the same
underlying operations in the Arithmetic Logic Unit (ALU).</p>
<ul>
<li><code>R</code>: register-register ALU instructions (<a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats#r-format">jump to section</a>)</li>
<li><code>I</code>: ALU immediate instructions, load instructions (<a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats#i-format">jump to
section</a>)</li>
<li><code>S</code> / <code>B</code>: store instructions, comparison and branch instructions (<a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats#s-format">jump to
section</a>)</li>
<li><code>U</code> / <code>J</code>: jump instructions, jump and link instructions (<a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats#u-format">jump to
section</a>)</li>
</ul>
<p>Each of the instructions we saw in our generated assembly adheres to one of
these formats. The four instructions we specifically identified map as follows:</p>
<ul>
<li><code>addi</code>: I Format</li>
<li><code>sd</code>: S Format</li>
<li><code>lui</code>: U Format</li>
<li><code>addw</code>: R Format</li>
</ul>
<p>Let&rsquo;s take a look at each of these formats and explore why they are appropriate
for different instruction types.</p>
<h2 id="why-multiple-formats">
  Why Multiple Formats?
  <a class="heading-link" href="#why-multiple-formats">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>We already answered this abstractly by saying that we need to encode operations
in binary for the processor to understand them. However, what does that mean
concretely? At its most basic level a CPU is a set of logic gates that are
composed together to offer higher-level abstractions (such as the instructions
we write in assembly). In order to know what signals to pass to the various
modules that perform data operations, the CPU must know what we are asking it to
do.</p>
<h4 id="a-metaphor-for-humans">
  A Metaphor for Humans
  <a class="heading-link" href="#a-metaphor-for-humans">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<blockquote>
<p>This brief section attempts to draw parallels to how two humans might
communicate. If you are already familiar with how instructions are represented
on a machine, or you just don&rsquo;t like metaphors (which, quite frankly,
typically describes me), you may want to <a href="https://danielmangum.com/posts/risc-v-bytes-intro-instruction-formats#back-to-computers">skip ahead</a>.</p>
</blockquote>
<p>Imagine you were coordinating a time-sensitive event with a friend, but all
communication had to happen via individual messages with length of 30
alphanumeric characters or less. Further imagine that you could only send one
message per hour. One option would be to explain everything you needed them to
do explicitly, writing in common prose. For example, if you wanted them to go
buy some food for the event, you could say &ldquo;Go to the store on Main Street&rdquo;,
then an hour later say &ldquo;Buy seven wheat hamburger buns&rdquo;. However, if the store
was only 5 minutes away, our friend would have to wait for 55 minutes until they
got the subsequent message telling them what to do at the store.</p>
<p>A more efficient strategy, assuming prior planning was permitted, would be to
agree upon a set of tasks that our friend was capable of doing and a way to
encode those tasks as characters other then the very inefficient English
encoding we just demonstrated. When we say &ldquo;Go to the store on Main Street&rdquo; we
are really just providing an action (&ldquo;Go to&rdquo;), a recipient of that action
(&ldquo;store&rdquo;), and a modifier of the recipient (&ldquo;on Main Street&rdquo;), each of which
could be specified with a single character or a small group of characters,
instead of the 30 characters we are using. However, our friend needs to know how
many characters are dedicated to defining each segment of the task in order to
distinguish where one ends and the next begins. The decision on how many
characters are required to represent each comes down to how many different
variations we need. With alphanumeric characters (A-Z, 0-9, case-insensitive),
we can describe 36 variations in a single character. If our friend is capable of
36 or less actions, the most efficient way to communicate the action to them is
with a single character. On the other hand, let&rsquo;s say there are more than 36
action recipients that we need to encode. By using two characters, we are
suddenly able to encode 1296 action recipients (<code>36^2 = 1296</code>)! So at this
point, we are able to represent in 3 characters (1 for the action, 2 for the
recipient) what we were previously representing in 15 (&ldquo;Go to the store&rdquo;).</p>
<p>For the last part of the instruction, there are many ways that we could describe
the store, so we may need a few characters. In our English example, we only had
enough characters to communicate the street name of the store. If we can
communicate its location in a more efficient format, we could be much more
specific. For completeness, let&rsquo;s say the remaining 27 characters are used to
encode the location of the store (giving us <code>36^27</code> options!). We can now
communicate the full street address to our friend, demonstrating the ability to
represent more information when a format for communicating that information is
predefined.</p>
<p>However, when we look at our next instruction, &ldquo;Buy seven wheat hamburger buns&rdquo;,
we notice a problem. We now have an action (&ldquo;Buy&rdquo;) and a recipient (&ldquo;hamburger
buns&rdquo;), but two (&ldquo;seven&rdquo; and &ldquo;wheat&rdquo;) recipient modifiers. Attempting to encode
this task in the same format as we did for going to the store will result in
confusion for our friend as they try to decipher the encoding of &ldquo;seven&rdquo; and
&ldquo;wheat&rdquo; into a location (i.e. street address) of the hamburger buns they are
buying. We have now identified two separate classes of tasks, and they require
different information to be presented in their encoding. Our &ldquo;Buy&rdquo; action would
prefer to split those characters we used to describe the location of the store
in the first task into multiple modifiers of the object being bought.</p>
<p>How can we accommodate both of these (and potentially more) classes of tasks?
One manner of doing so would be to dedicate one or a few characters at the
beginning of our message to describing how the remainder of the task is going to
be formatted. For instance, if we reserve the first character for describing the
class of task, our friend can know that if the first character is &ldquo;A&rdquo;, the
remainder of the message will contain an action, a recipient, and a single long
modifier. If the first character is &ldquo;B&rdquo;, the message will contain an action, a
recipient, and two shorter modifiers.</p>
<h4 id="back-to-computers">
  Back to Computers
  <a class="heading-link" href="#back-to-computers">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Similar to our strategy of encoding the type of task we are communicating to our
friend with a single character, RISC-V defines the class of task (instruction
format) using a fixed-length <code>opcode</code> in the 7 least significant bits of every
instruction.</p>
<blockquote>
<p>Importantly, though the <code>opcode</code> does encode the instruction format, it is
also used to indicate other information about the specific instruction. For
this reason, two <code>R</code> format instructions, for instance, may not have the same
7 bit <code>opcode</code>. However, because the <code>opcode</code> eventually gets transformed into
control signals, you will see at least similar, if not identical, <code>opcodes</code>
for instructions of the same format.</p>
</blockquote>
<p>It can be helpful to think about each instruction format as making a different
tradeoff between how it utilizes the 25 remaining bits it is allocated. Some
instructions may only need to use general purpose registers as operands, and
since there are only 32 general purpose registers, they can all be addressed
with just 5 bits (<code>2^5 = 31</code>). This leaves room for more instruction types in
that format by utilizing the remaining bits to encode the operation (we&rsquo;ll see
an example of this with the <code>funct3</code> and <code>funct7</code> fields in <code>R</code> format
instructions). Other instructions may only need a single register operand, but
require the ability to pass a large constant value (<code>U</code> format instructions are
a good example of this).</p>
<p>The following sections describe how each instruction format caters to different
types of operations we want to perform.</p>
<h2 id="r-format">
  R Format
  <a class="heading-link" href="#r-format">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>R</code> format instructions are frequently thought of as the most &ldquo;simple&rdquo; because
they typically include operations that map closely to the capabilities that we
generally associate with a computer at the lowest level. Arithmetic operations,
such as adding, subtracting, and bit shifting all fall into this category.</p>
<p>We picked out <code>addw</code> as an instruction from our example that adheres to the <code>R</code>
format. Let&rsquo;s take a look at the 4 bytes at that address in binary:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt  0x101b8           
</span></span><span style="display:flex;"><span>0x101b8 &lt;sum&gt;:      00111011    00000101    10110101    00000000
</span></span></code></pre></div><p>RISC-V is a <a href="https://en.wikipedia.org/wiki/Endianness">little endian
architecture</a>, meaning that the least
significant byte is stored at the smallest memory address. If we take the 4
bytes at <code>0x101b8</code>, which is the location of our <code>addw</code> instruction, we can
re-arrange the bytes so that the least significant bit (LSB) is on the right and
the most significant bit (MSB) is on the right:</p>
<p><code>00000000 10110101 00000101 00111011</code></p>
<p>Now we can fit this into the <code>R</code> format we defined earlier:</p>
<p><img src="../../static/risc_v_inst_intro_2.png" alt="addw R Format"></p>
<p>Let&rsquo;s break down the components of this instruction. As is true for all of our
core formats, the first 7 bits (<code>[6:0]</code>) represent our <code>opcode</code>. Here our opcode
is <code>0111011</code>. This informs the CPU what format, and, depending on the
instruction, the exact operation that needs to be performed on the operands. In
cases where the <code>opcode</code> does not correspond to a single instruction, it informs
the CPU where to look for more information. In <code>R</code> format instructions, both
<code>funct3</code> and <code>funct7</code> fields are supported, and they are used to specify the
exact instruction that should be executed. We will dive into exactly how the
<code>opcode</code> is decoded and transformed into control signals in a future post, but
as an example of how the <code>opcode</code> and <code>funct</code> fields are used to specify an
instruction, we can compare the three fields for <code>addw</code> and <code>subw</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:center">Instruction</th>
<th style="text-align:center">opcode</th>
<th style="text-align:center">funct3</th>
<th style="text-align:center">funct7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>addw</code></td>
<td style="text-align:center"><code>0111011</code></td>
<td style="text-align:center"><code>000</code></td>
<td style="text-align:center"><code>0000000</code></td>
</tr>
<tr>
<td style="text-align:center"><code>subw</code></td>
<td style="text-align:center"><code>0111011</code></td>
<td style="text-align:center"><code>000</code></td>
<td style="text-align:center"><code>0100000</code></td>
</tr>
</tbody>
</table>
<p>As observed, the only difference is a single bit in the <code>funct7</code> field, but this
is enough to inform the CPU of how to operate on <code>rs1</code>, <code>rs2</code>, and <code>rd</code>. This is
an example of a format allowing for more types of instructions to be defined
because the size of the operands are small (5 bits each).</p>
<p>Speaking of the operands, we haven&rsquo;t examined the values of <code>rs1</code>, <code>rs2</code>, and
<code>rd</code> yet. The first thing you will notice is that <code>rs1</code> and <code>rsd</code> contain the
exact same bit sequence: <code>01010</code>. This should come as no surprise if we look
back our instruction, which uses <code>a0</code> twice: <code>addw a0,a0,a1</code>. How does this
sequence of bits correspond to <code>a0</code> though? If you remember our table of general
purpose registers (GPRs) from earlier posts, you&rsquo;ll recognize <code>a0</code> as the
mnemonic for the first &ldquo;argument register&rdquo;. A truncated version of the table is
reproduced below as a refresher:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>ABI Mnemonic</th>
<th>Calling Convention</th>
<th>Preserved across calls?</th>
</tr>
</thead>
<tbody>
<tr>
<td>x10-x17</td>
<td>a0-a7</td>
<td>Argument registers</td>
<td>No</td>
</tr>
</tbody>
</table>
<p>We can see that <code>a0</code> corresponds to GPR <code>x10</code>, and if we convert our <code>rs1</code> and
<code>rd</code> values (<code>01010</code>) to decimal, we see the value is <code>10</code>!</p>
<blockquote>
<p>Quick refresher on converting binary to decimal: <code>0(1) + 1(2) + 0(4) + 1(8) + 0(16) = 10</code>.</p>
</blockquote>
<p>Likewise, the value of <code>rs2</code> (<code>01011</code>) is <code>11</code> when converted to decimal,
corresponding to <code>x11</code>.</p>
<h2 id="i-format">
  I Format
  <a class="heading-link" href="#i-format">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><code>I</code> format instructions eliminate the second register (<code>rs2</code>) and function
(<code>funct7</code>) fields from the <code>R</code> format in favor of a large <em>immediate value</em>
field. This format is specifically useful for supplying constants for arithmetic
instructions, or loading data from a location in memory. We&rsquo;ll take a look at
both of those here.</p>
<p>The instruction we chose as representing <code>I</code> format instructions from our
example was <code>addi</code> (&ldquo;add immediate&rdquo;). We&rsquo;ll examine the first instance of the
instruction, which is used to increase the size of the stack by decrementing the
stack pointer <code>sp</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x100b0 
</span></span><span style="display:flex;"><span>0x100b0 &lt;main&gt;: 00010011    00000001    00000001    11111111
</span></span></code></pre></div><p>Rearranging the bits and fitting into the <code>I</code> format gives us the following:</p>
<p><code>11111111 00000001 00000001 00010011</code></p>
<p><img src="../../static/risc_v_inst_intro_3.png" alt="addi I Format"></p>
<p>Let&rsquo;s again look at a truncated table of RISC-V GPRs:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>ABI Mnemonic</th>
<th>Calling Convention</th>
<th>Preserved across calls?</th>
</tr>
</thead>
<tbody>
<tr>
<td>x2</td>
<td>sp</td>
<td>Stack pointer</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<p>Unsurprisingly again, our <code>rd</code> and <code>rs1</code> fields are identical, both
corresponding to the stack pointer register <code>sp</code> (<code>00010</code> is <code>2</code> in decimal,
<code>sp</code> is register <code>x2</code>). Our immediate value (<code>111111110000</code>) looks a little
strange though. Our instruction specified <code>addi sp,sp,-16</code>, but if we convert
<code>111111110000</code> to decimal we get <code>4080</code>?</p>
<p>We have demonstrated multiple times at this point how decimal numbers can be
represented in binary, but what if we need to represent a negative number, as we
do here? RISC-V, and almost every other modern machine, uses <a href="https://en.wikipedia.org/wiki/Two%27s_complement">Two&rsquo;s
Complement</a>. We will go into
more depth in a future post about why Two&rsquo;s Complement is friendly to hardware
designers, but for the purposes of this post, we can make the simple observation
that any binary number with a <code>1</code> in the most significant bit position
(<code>imm[11]</code> in this case), is negative, and its decimal value can be ascertained
by inverting all bits, converting to decimal, and adding 1. Let&rsquo;s do that here:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># Invert bits
</span></span><span style="display:flex;"><span>111111110000 =&gt; 000000001111
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># Convert to decimal
</span></span><span style="display:flex;"><span>000000001111 = 1(1) + 1(2) + 1(4) + 1(8) = 15
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># Add 1
</span></span><span style="display:flex;"><span>15 + 1 = 16
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># Add sign
</span></span><span style="display:flex;"><span>-16
</span></span></code></pre></div><p>In summation, our instruction has specified that <code>-16</code> be added to the value in
the <code>sp</code> register, and the result be stored in the <code>sp</code> register, effectively
increasing the size of our downward growing stack.</p>
<p>Before we move on to the next instruction format, let&rsquo;s look at another <code>I</code>
format instruction from our example that looks fairly different than <code>addi</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00000000000100d4 &lt;+36&gt;:        ld          ra,8(sp)
</span></span></code></pre></div><p>Here we are loading the contents of the memory location 8 bytes greater than the
location stored in <code>sp</code> and storing it in the return address register (<code>ra</code>).
The <code>8</code> in this instruction is frequently referred to as an <em>offset</em>. Let&rsquo;s look
at the binary representation:</p>
<blockquote>
<p>The <code>d</code> in <code>ld</code> stands for &ldquo;doubleword&rdquo; which indicates the size of the data
at the memory location is 64 bits.</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x100d4
</span></span><span style="display:flex;"><span>0x100d4 &lt;main+36&gt;:  10000011    00110000    10000001    00000000
</span></span></code></pre></div><p>Rearranged: <code>00000000 10000001 00110000 10000011</code></p>
<p>Fit into <code>I</code> format:</p>
<p><img src="../../static/risc_v_inst_intro_4.png" alt="ld I Format"></p>
<p>The first thing you&rsquo;ll notice is that the <code>opcode</code> is different (though only by
a single bit), and we are using the <code>funct3</code> field to further describe how the
other fields should be interpreted. The rest of the instruction is similar to to
the others we have seen, <code>rd</code> corresponds to <code>ra</code> (<code>x1</code>), <code>rs1</code> corresponds to
<code>sp</code> (<code>x2</code>), and our immediate value represents our 8 byte offset. The
differences in these two instructions (<code>addi</code> and <code>ld</code>) demonstrate how a single
instruction format can be useful for multiple types of instructions, and we can
indicate to the CPU how fields should be interpreted using our <code>opcode</code> and
<code>funct</code> fields.</p>
<h2 id="s-format">
  S Format
  <a class="heading-link" href="#s-format">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Next up is <code>S</code> format instructions, which reintroduce our second register
operand (<code>rs2</code>), but eliminate the destination register <code>rd</code>. An important
attribute to notice is that we don&rsquo;t simply change the bits used for <code>rd</code> to now
represent <code>rs2</code>, we instead split our immediate value across two separate
fields, allowing <code>rs2</code> to be placed in the same location in <code>S</code> format
instructions as it was in <code>R</code> format (and every other format that utilizes
<code>rs2</code>). When we explore how instruction decoding works, the reasoning behind
this strategy and the impact it has on complexity of the hardware design will
become more apparent.</p>
<p>Our chosen <code>S</code> format instruction is <code>sd</code> which is used to store a doubleword at
a location in memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x100bc
</span></span><span style="display:flex;"><span>0x100bc &lt;main+12&gt;:  00100011    00110100    00010001    00000000
</span></span></code></pre></div><p>Rearranged: <code>00000000 00010001 00110100 00100011</code></p>
<p>Fit into <code>S</code> format:</p>
<p><img src="../../static/risc_v_inst_intro_5.png" alt="sd S Format"></p>
<p>This looks somewhat similar to our <code>ld</code> instruction, but instead of storing the
contents of a memory location in a register, we are storing the contents of a
register in a memory location. In this case, the contents of <code>ra</code> are being
stored at the memory location specified by the sum of the contents of our <code>sp</code>
register and <code>8</code>, which is the decimal value of our immediate: <code>000000001000</code>.</p>
<blockquote>
<p>The practice of deriving a memory address by taking the sum of a register&rsquo;s
contents and an immediate offset is commonly referred to as <strong>base</strong> or
<strong>displacement addressing</strong>.</p>
</blockquote>
<p>As mentioned earlier, the <code>B</code> format is often grouped with <code>S</code> because it is
only slightly different. The difference is rooted in the fact that the <code>B</code>
format is typically used for conditional branching instructions, where the
immediate value is used to specify the memory location where execution should
continue if the comparison evaluates to <code>true</code>. If you remember the beginning of
this post, we mentioned that all instructions in RISC-V are 32 bits wide (or 16
bits wide if using compressed instructions). As a consequence, we will only ever
be branching to a memory location that is a multiple of 2. Therefore, specifying
the least significant bit in our immediate value would be a waste of space (it
will always be a <code>0</code>). Instead, we use the 8th bit in the instruction to
represent the 12th bit in our immediate value (<code>imm[11]</code>). In doing so, we are
able to re-use much of the hardware utilized for evaluating <code>S</code> format
instructions because the sign bit of the immediate value (<code>imm[12]</code>) is in the
same location, as are the middle bits of the immediate value (<code>imm[10:1]</code>). We
are also able to specify larger immediate values because we have 13 bits instead
of just 12.</p>
<p>Though we don&rsquo;t have any <code>B</code> format instructions in our example program, let&rsquo;s
take a look at how we could decode a <code>blt</code> instruction if it existed:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>0x00000000000101b8 &lt;+0&gt;:    blt a1,a0,0x101c4 &lt;sum+12&gt;
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x101b8
</span></span><span style="display:flex;"><span>0x101b8 &lt;sum&gt;:  01100011    11000110    10100101    00000000
</span></span></code></pre></div><p>Rearranged: <code>00000000 10100101 11000110 01100011</code></p>
<p>Fit into <code>B</code> format:</p>
<p><img src="../../static/risc_v_inst_intro_6.png" alt="blt B Format"></p>
<p>Since we&rsquo;ve seen it a few times at this point, I&rsquo;ll leave the register decoding
to you, but let&rsquo;s briefly evaluate our immediate. Remember that we infer a <code>0</code>
in the least significant bit (<code>imm[0]</code>):</p>
<p><code>0000000001100</code></p>
<blockquote>
<p>In practice, immediate values are
<a href="https://en.wikipedia.org/wiki/Sign_extension">sign-extended</a>, but we
represent them without sign-extension in this post to more clearly show the
mapping of bits in the instruction to bits in the immediate.</p>
</blockquote>
<p>Converting to decimal, we get a value of <code>12</code>, which, as we can see from our
assembler directive above, is the number of bytes (i.e. offset) between the
current instruction memory address (<code>0x101b8</code>) and <code>0x101c4</code>.</p>
<h2 id="u-format">
  U Format
  <a class="heading-link" href="#u-format">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Our last instruction format is <code>U</code>, which we chose the <code>lui</code> instruction to
demonstrate, but didn&rsquo;t specify its actual purpose. <code>lui</code> refers to &ldquo;load upper
immediate&rdquo;, and now that we have looked at a few instructions that use immediate
values, we should have somewhat of an intuition for how it is used. The <code>U</code>
format has the smallest number of fields out of all core instruction formats,
only supporting <code>opcode</code>, <code>rd</code>, and a 20 bit immediate.</p>
<p>We have already seen control flow instructions in the <code>SB</code> format with
conditional branching, but we did not observe the limitations. Because the size
of our immediate in <code>SB</code> instructions was limited to 13 bits, the total memory
address space that could be accessed in a single jump is limited. For this
reason, conditional branching is frequently used for small, local jumps.</p>
<p>Before we go farther, let&rsquo;s break our <code>lui</code> instruction down into its <code>U</code> format
layout:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x100c8
</span></span><span style="display:flex;"><span>0x100c8 &lt;main+24&gt;:  00110111    00010101    00000010    00000000
</span></span></code></pre></div><p>Rearranged: <code>00000000 00000010 00010101 00110111</code></p>
<p>Fit into <code>U</code> format:</p>
<p><img src="../../static/risc_v_inst_intro_7.png" alt="lui U Format"></p>
<p>If we need to jump to or reference a farther away memory address, we have to
build up our constant via multiple instructions. This is where <code>lui</code> comes in.
The 20 bit immediate value in the <code>U</code> format instruction is placed in the upper
20 bits of the register specified in <code>rd</code>, which is <code>a0</code> here. The <code>lui</code>
instruction is frequently coupled with <code>addi</code>, which allows us to then specify
the lower bits of that constant using binary addition before using it to access
that location in memory.</p>
<p>In fact, in our example, <code>lui</code> is coupled with <code>addi</code> to build up the memory
address of the format string that we pass to <code>printf</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>   0x00000000000100c8 &lt;+24&gt;:        lui         a0,0x21
</span></span><span style="display:flex;"><span>   0x00000000000100cc &lt;+28&gt;:        addi        a0,a0,-192 # 0x20f40
</span></span><span style="display:flex;"><span>   0x00000000000100d0 &lt;+32&gt;:        jal         ra,0x10418 &lt;printf&gt;
</span></span></code></pre></div><p>Let&rsquo;s step through these instructions to observe what is happening:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) disass
</span></span><span style="display:flex;"><span>Dump of assembler code for function main:
</span></span><span style="display:flex;"><span>   0x00000000000100b0 &lt;+0&gt;: addi    sp,sp,-16
</span></span><span style="display:flex;"><span>   0x00000000000100b4 &lt;+4&gt;: li  a1,2
</span></span><span style="display:flex;"><span>   0x00000000000100b8 &lt;+8&gt;: li  a0,1
</span></span><span style="display:flex;"><span>   0x00000000000100bc &lt;+12&gt;:    sd  ra,8(sp)
</span></span><span style="display:flex;"><span>   0x00000000000100c0 &lt;+16&gt;:    jal ra,0x101b8 &lt;sum&gt;
</span></span><span style="display:flex;"><span>   0x00000000000100c4 &lt;+20&gt;:    mv  a1,a0
</span></span><span style="display:flex;"><span>=&gt; 0x00000000000100c8 &lt;+24&gt;:    lui a0,0x21
</span></span><span style="display:flex;"><span>   0x00000000000100cc &lt;+28&gt;:    addi    a0,a0,-192 # 0x20f40
</span></span><span style="display:flex;"><span>   0x00000000000100d0 &lt;+32&gt;:    jal ra,0x10418 &lt;printf&gt;
</span></span><span style="display:flex;"><span>   0x00000000000100d4 &lt;+36&gt;:    ld  ra,8(sp)
</span></span><span style="display:flex;"><span>   0x00000000000100d8 &lt;+40&gt;:    li  a0,0
</span></span><span style="display:flex;"><span>   0x00000000000100dc &lt;+44&gt;:    addi    sp,sp,16
</span></span><span style="display:flex;"><span>   0x00000000000100e0 &lt;+48&gt;:    ret
</span></span><span style="display:flex;"><span>End of assembler dump.
</span></span><span style="display:flex;"><span>(gdb) i r a0        
</span></span><span style="display:flex;"><span>a0             0x3  3
</span></span></code></pre></div><p>At the start, the content of <code>a0</code> is <code>3</code>, which is the result from our <code>sum</code>
function. In binary this would look like: <code>00000000000000000000000000000011</code>.
Now let&rsquo;s step into the <code>lui</code> instruction and examine the contents:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si
</span></span><span style="display:flex;"><span>0x00000000000100cc in main ()
</span></span><span style="display:flex;"><span>(gdb) i r a0
</span></span><span style="display:flex;"><span>a0             0x21000  135168
</span></span></code></pre></div><p>After the <code>lui</code> instruction is executed, the upper 20 bits of <code>a0</code> are populated
with the immediate value&rsquo;s bits (<code>0x21</code>), and the lower 12 bits are filled in
with <code>0</code>&rsquo;s. In binary, our immediate was <code>00000000000000100001</code>, and and adding
12 <code>0</code>&rsquo;s to the end gives us <code>00000000000000100001000000000000</code> (or <code>0x2100</code>).
Now let&rsquo;s step into the <code>addi</code> instruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) si
</span></span><span style="display:flex;"><span>0x00000000000100d0 in main ()
</span></span><span style="display:flex;"><span>(gdb) i r a0
</span></span><span style="display:flex;"><span>a0             0x20f40  134976
</span></span></code></pre></div><p>We can tell from the changed decimal representation that we have added <code>-192</code> to
<code>a0</code>, but visualizing the binary addition helps us understand how <code>lui</code> and
<code>addi</code> are working together:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  00000000000000100001000000000000 (contents of a0 = 135168)
</span></span><span style="display:flex;"><span>+ 11111111111111111111111101000000 (sign-extended immediate = -192)
</span></span><span style="display:flex;"><span>----------------------------------
</span></span><span style="display:flex;"><span>  00000000000000100000111101000000
</span></span></code></pre></div><p>Now we pass this value in our <code>a0</code> argument register to <code>printf</code>, which points
to the address of the first character in our format string. We can examine the
contents of the memory address to be certain:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/15bc 0x20f40
</span></span><span style="display:flex;"><span>0x20f40:    84 &#39;T&#39;  104 &#39;h&#39; 101 &#39;e&#39; 32 &#39; &#39;  115 &#39;s&#39; 117 &#39;u&#39; 109 &#39;m&#39; 32 &#39; &#39;
</span></span><span style="display:flex;"><span>0x20f48:    105 &#39;i&#39; 115 &#39;s&#39; 58 &#39;:&#39;  32 &#39; &#39;  37 &#39;%&#39;  100 &#39;d&#39; 10 &#39;\n&#39;
</span></span></code></pre></div><p>Like the <code>S</code> and <code>B</code> formats, <code>U</code> and <code>J</code> are also quite similar. The immediate
in <code>J</code> is scrambled in a similar manner to <code>B</code> because it is also used for
control flow instructions, which must use a memory address that is a multiple of
2. In our example, <code>jal</code> (&ldquo;jump and link&rdquo;) is our only <code>J</code> format instruction,
and is actually the only core instruction that uses the <code>J</code> format. Let&rsquo;s
check out what it is doing:</p>
<div class="highlight"><pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>(gdb) x/4bt 0x100c0
</span></span><span style="display:flex;"><span>0x100c0 &lt;main+16&gt;:  11101111    00000000    10000000    00001111
</span></span></code></pre></div><p>Rearranged: <code>00001111 10000000 00000000 11101111</code></p>
<p>Fit into <code>J</code> format:</p>
<p><img src="../../static/risc_v_inst_intro_8.png" alt="jal J Format"></p>
<p>The <code>jal</code> instruction populates the register specified in <code>rd</code> (in this case
<code>ra</code>) with the memory address in the program counter (<code>pc</code>) register plus 4,
then jumps to the address by populating <code>pc</code> with the immediate value. In this
specific example, we are transferring control to the <code>sum</code> function, but making
sure that <code>ra</code> points to the instruction right after <code>jal</code> so that <code>sum</code> knows
where to return after completing its operations.</p>
<h2 id="what-is-going-on-with-mv-and-ret">
  What is going on with <code>mv</code> and <code>ret</code>?
  <a class="heading-link" href="#what-is-going-on-with-mv-and-ret">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>Before we conclude, I want to briefly touch on two instructions in our example
that we have not yet covered. You may have already noticed <code>ret</code> as it has no
operands, which would exclude it from all of the formats we have looked at.
<code>mv</code>, on the other hand, appears to use the <code>R</code> format, but actually is using
<code>I</code>.</p>
<p>These are both examples of <em>pseudoinstructions</em>, which are handy instructions
that make life easier for programmers, but are not specifically implemented in
hardware. Under the hood, our <code>mv a1,a0</code> instruction is actually <code>addi a1,a0,0</code>,
which accomplishes a &ldquo;move&rdquo; of one register&rsquo;s contents to another by adding 0.
Similarly, <code>ret</code> uses an instruction we didn&rsquo;t cover in this post, <code>jalr</code>, which
behaves similar to <code>jal</code>, but uses a register and an offset rather than an
immediate value. <code>ret</code> is implemented as <code>jalr x0,0(ra)</code>, which jumps to the
memory address in <code>ra</code> and essentially discards the link value as <code>x0</code> is
hard-coded to <code>0</code> in RISC-V.</p>
<blockquote>
<p>We see another optimization in RISC-V here with a register (<code>x0</code>) that is
hard-coded to <code>0</code>. We&rsquo;ll explore more use cases for this functionality in a
future post.</p>
</blockquote>
<p>There are more pseudoinstructions that the assembler implements than these two,
some of which encompass multiple underlying instructions, but <code>mv</code> and <code>ret</code> are
ones that you will see often.</p>
<h2 id="concluding-thoughts">
  Concluding Thoughts
  <a class="heading-link" href="#concluding-thoughts">
    <i class="fa fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>This has been our longest post in the series so far, but it provides a strong
grounding for future topics we will cover. Specifically, there are a number of
design decisions that were only briefly mentioned or alluded to that we will
explore in more depth. In addition, we will move beyond statements like &ldquo;it
makes the hardware implementation simpler&rdquo; to actually showing how the logic is
implemented.</p>
<p>As always, these posts are meant to serve as a useful resource for folks who are
interested in learning more about RISC-V and low-level software in general. If I
can do a better job of reaching that goal, or you have any questions or
comments, please feel free to send me a message
<a href="https://twitter.com/hasheddan">@hasheddan</a> on Twitter!</p>

      </div>


      <footer>
        


        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
    2023
     Daniel Mangum 
    Â·
    
    Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="https://danielmangum.com/js/coder.min.27afce394fb6284f521b3fbc9f6a8326342333c3092267f3944d770489876fed.js" integrity="sha256-J6/OOU&#43;2KE9SGz&#43;8n2qDJjQjM8MJImfzlE13BImHb&#43;0="></script>
  

  

  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-116820283-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  

  

  

  

  

  

  
</body>

</html>
